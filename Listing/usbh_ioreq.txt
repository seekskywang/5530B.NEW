; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\usbh_ioreq.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\usbh_ioreq.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\usbh_ioreq.crf ..\USB\STM32_USB_HOST_Library\Core\src\usbh_ioreq.c]
                          THUMB

                          AREA ||i.USBH_BulkReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_BulkReceiveData PROC
;;;277      */
;;;278    USBH_Status USBH_BulkReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;279                                    uint8_t *buff, 
;;;280                                    uint16_t length,
;;;281                                    uint8_t hc_num)
;;;282    {
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;283      pdev->host.hc[hc_num].ep_is_in = 1;   
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  2301              MOVS     r3,#1
00000c  f88433ae          STRB     r3,[r4,#0x3ae]
000010  e9c4c2ee          STRD     r12,r2,[r4,#0x3b8]
;;;284      pdev->host.hc[hc_num].xfer_buff = buff;
;;;285      pdev->host.hc[hc_num].xfer_len = length;
;;;286      
;;;287    
;;;288      if( pdev->host.hc[hc_num].toggle_in == 0)
000014  f89423c4          LDRB     r2,[r4,#0x3c4]
000018  b102              CBZ      r2,|L1.28|
;;;289      {
;;;290        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
;;;291      }
;;;292      else
;;;293      {
;;;294        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
00001a  2202              MOVS     r2,#2
                  |L1.28|
00001c  f88423b4          STRB     r2,[r4,#0x3b4]
;;;295      }
;;;296    
;;;297      HCD_SubmitRequest (pdev , hc_num);  
000020  f7fffffe          BL       HCD_SubmitRequest
;;;298      return USBH_OK;
000024  2000              MOVS     r0,#0
;;;299    }
000026  bd10              POP      {r4,pc}
;;;300    
                          ENDP


                          AREA ||i.USBH_BulkSendData||, CODE, READONLY, ALIGN=1

                  USBH_BulkSendData PROC
;;;244      */
;;;245    USBH_Status USBH_BulkSendData ( USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;246                                    uint8_t *buff, 
;;;247                                    uint16_t length,
;;;248                                    uint8_t hc_num)
;;;249    { 
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;250      pdev->host.hc[hc_num].ep_is_in = 0;
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  2300              MOVS     r3,#0
00000c  f88433ae          STRB     r3,[r4,#0x3ae]
000010  e9c4c2ee          STRD     r12,r2,[r4,#0x3b8]
;;;251      pdev->host.hc[hc_num].xfer_buff = buff;
;;;252      pdev->host.hc[hc_num].xfer_len = length;  
;;;253    
;;;254     /* Set the Data Toggle bit as per the Flag */
;;;255      if ( pdev->host.hc[hc_num].toggle_out == 0)
000014  f89423c5          LDRB     r2,[r4,#0x3c5]
000018  b132              CBZ      r2,|L2.40|
;;;256      { /* Put the PID 0 */
;;;257          pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
;;;258      }
;;;259     else
;;;260     { /* Put the PID 1 */
;;;261          pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
00001a  2202              MOVS     r2,#2
00001c  f88423b4          STRB     r2,[r4,#0x3b4]
                  |L2.32|
;;;262     }
;;;263    
;;;264      HCD_SubmitRequest (pdev , hc_num);   
000020  f7fffffe          BL       HCD_SubmitRequest
;;;265      return USBH_OK;
000024  2000              MOVS     r0,#0
;;;266    }
000026  bd10              POP      {r4,pc}
                  |L2.40|
000028  f88433b4          STRB     r3,[r4,#0x3b4]        ;257
00002c  e7f8              B        |L2.32|
;;;267    
                          ENDP


                          AREA ||i.USBH_CtlReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_CtlReceiveData PROC
;;;217      */
;;;218    USBH_Status USBH_CtlReceiveData(USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;219                                    uint8_t* buff, 
;;;220                                    uint16_t length,
;;;221                                    uint8_t hc_num)
;;;222    {
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;223    
;;;224      pdev->host.hc[hc_num].ep_is_in = 1;
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  f504746b          ADD      r4,r4,#0x3ac
00000e  2301              MOVS     r3,#1
000010  70a3              STRB     r3,[r4,#2]
;;;225      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000012  f04f0302          MOV      r3,#2
000016  7223              STRB     r3,[r4,#8]
000018  e9c4c203          STRD     r12,r2,[r4,#0xc]
;;;226      pdev->host.hc[hc_num].xfer_buff = buff;
;;;227      pdev->host.hc[hc_num].xfer_len = length;  
;;;228    
;;;229      HCD_SubmitRequest (pdev , hc_num);   
00001c  f7fffffe          BL       HCD_SubmitRequest
;;;230      
;;;231      return USBH_OK;
000020  2000              MOVS     r0,#0
;;;232      
;;;233    }
000022  bd10              POP      {r4,pc}
;;;234    
                          ENDP


                          AREA ||i.USBH_CtlReq||, CODE, READONLY, ALIGN=1

                  USBH_CtlReq PROC
;;;104      */
;;;105    USBH_Status USBH_CtlReq     (USB_OTG_CORE_HANDLE *pdev, 
000000  b530              PUSH     {r4,r5,lr}
;;;106                                 USBH_HOST           *phost, 
;;;107                                 uint8_t             *buff,
;;;108                                 uint16_t            length)
;;;109    {
;;;110      USBH_Status status;
;;;111      status = USBH_BUSY;
000002  2001              MOVS     r0,#1
;;;112      
;;;113      switch (phost->RequestState)
000004  78cd              LDRB     r5,[r1,#3]
000006  4604              MOV      r4,r0                 ;111
000008  2d01              CMP      r5,#1
00000a  d00b              BEQ      |L4.36|
00000c  2d02              CMP      r5,#2
00000e  d108              BNE      |L4.34|
;;;114      {
;;;115      case CMD_SEND:
;;;116        /* Start a SETUP transfer */
;;;117        USBH_SubmitSetupRequest(phost, buff, length);
;;;118        phost->RequestState = CMD_WAIT;
;;;119        status = USBH_BUSY;
;;;120        break;
;;;121        
;;;122      case CMD_WAIT:
;;;123         if (phost->Control.state == CTRL_COMPLETE ) 
000010  7f0a              LDRB     r2,[r1,#0x1c]
000012  2a0d              CMP      r2,#0xd
000014  d010              BEQ      |L4.56|
;;;124        {
;;;125          /* Commands successfully sent and Response Received  */       
;;;126          phost->RequestState = CMD_SEND;
;;;127          phost->Control.state =CTRL_IDLE;  
;;;128          status = USBH_OK;      
;;;129        }
;;;130        else if  (phost->Control.state == CTRL_ERROR)
000016  2a0b              CMP      r2,#0xb
000018  d012              BEQ      |L4.64|
;;;131        {
;;;132          /* Failure Mode */
;;;133          phost->RequestState = CMD_SEND;
;;;134          status = USBH_FAIL;
;;;135        }   
;;;136         else if  (phost->Control.state == CTRL_STALLED )
00001a  2a0c              CMP      r2,#0xc
00001c  d101              BNE      |L4.34|
;;;137        {
;;;138          /* Commands successfully sent and Response Received  */       
;;;139          phost->RequestState = CMD_SEND;
00001e  70cc              STRB     r4,[r1,#3]
;;;140          status = USBH_NOT_SUPPORTED;
000020  2003              MOVS     r0,#3
                  |L4.34|
;;;141        }
;;;142        break;
;;;143        
;;;144      default:
;;;145        break; 
;;;146      }
;;;147      return status;
;;;148    }
000022  bd30              POP      {r4,r5,pc}
                  |L4.36|
000024  780d              LDRB     r5,[r1,#0]
000026  704d              STRB     r5,[r1,#1]
000028  2507              MOVS     r5,#7
00002a  700d              STRB     r5,[r1,#0]
00002c  608a              STR      r2,[r1,#8]
00002e  818b              STRH     r3,[r1,#0xc]
000030  770c              STRB     r4,[r1,#0x1c]
000032  2202              MOVS     r2,#2                 ;118
000034  70ca              STRB     r2,[r1,#3]            ;118
000036  bd30              POP      {r4,r5,pc}
                  |L4.56|
000038  70cc              STRB     r4,[r1,#3]            ;126
00003a  2000              MOVS     r0,#0                 ;127
00003c  7708              STRB     r0,[r1,#0x1c]         ;127
00003e  bd30              POP      {r4,r5,pc}
                  |L4.64|
000040  70cc              STRB     r4,[r1,#3]            ;133
000042  2002              MOVS     r0,#2                 ;134
000044  bd30              POP      {r4,r5,pc}
;;;149    
                          ENDP


                          AREA ||i.USBH_CtlSendData||, CODE, READONLY, ALIGN=1

                  USBH_CtlSendData PROC
;;;178      */
;;;179    USBH_Status USBH_CtlSendData ( USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;180                                    uint8_t *buff, 
;;;181                                    uint16_t length,
;;;182                                    uint8_t hc_num)
;;;183    {
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;184      pdev->host.hc[hc_num].ep_is_in = 0;
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  2300              MOVS     r3,#0
00000c  f88433ae          STRB     r3,[r4,#0x3ae]
000010  e9c4c2ee          STRD     r12,r2,[r4,#0x3b8]
;;;185      pdev->host.hc[hc_num].xfer_buff = buff;
;;;186      pdev->host.hc[hc_num].xfer_len = length;
;;;187     
;;;188      if ( length == 0 )
000014  b11a              CBZ      r2,|L5.30|
;;;189      { /* For Status OUT stage, Length==0, Status Out PID = 1 */
;;;190        pdev->host.hc[hc_num].toggle_out = 1;   
;;;191      }
;;;192     
;;;193     /* Set the Data Toggle bit as per the Flag */
;;;194      if ( pdev->host.hc[hc_num].toggle_out == 0)
000016  f89423c5          LDRB     r2,[r4,#0x3c5]
00001a  b152              CBZ      r2,|L5.50|
00001c  e002              B        |L5.36|
                  |L5.30|
00001e  2201              MOVS     r2,#1                 ;190
000020  f88423c5          STRB     r2,[r4,#0x3c5]        ;190
                  |L5.36|
;;;195      { /* Put the PID 0 */
;;;196          pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
;;;197      }
;;;198     else
;;;199     { /* Put the PID 1 */
;;;200          pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
000024  2202              MOVS     r2,#2
000026  f88423b4          STRB     r2,[r4,#0x3b4]
                  |L5.42|
;;;201     }
;;;202    
;;;203      HCD_SubmitRequest (pdev , hc_num);   
00002a  f7fffffe          BL       HCD_SubmitRequest
;;;204       
;;;205      return USBH_OK;
00002e  2000              MOVS     r0,#0
;;;206    }
000030  bd10              POP      {r4,pc}
                  |L5.50|
000032  f88433b4          STRB     r3,[r4,#0x3b4]        ;196
000036  e7f8              B        |L5.42|
;;;207    
                          ENDP


                          AREA ||i.USBH_CtlSendSetup||, CODE, READONLY, ALIGN=1

                  USBH_CtlSendSetup PROC
;;;157      */
;;;158    USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
000000  468c              MOV      r12,r1
;;;159                                    uint8_t *buff, 
;;;160                                    uint8_t hc_num){
000002  4611              MOV      r1,r2
;;;161      pdev->host.hc[hc_num].ep_is_in = 0;
000004  eb001341          ADD      r3,r0,r1,LSL #5
000008  b510              PUSH     {r4,lr}               ;160
00000a  f503736b          ADD      r3,r3,#0x3ac
00000e  2200              MOVS     r2,#0
000010  709a              STRB     r2,[r3,#2]
;;;162      pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
000012  f04f0203          MOV      r2,#3
000016  721a              STRB     r2,[r3,#8]
;;;163      pdev->host.hc[hc_num].xfer_buff = buff;
;;;164      pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
000018  f04f0208          MOV      r2,#8
00001c  e9c3c203          STRD     r12,r2,[r3,#0xc]
;;;165    
;;;166      return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
000020  f7fffffe          BL       HCD_SubmitRequest
000024  b2c0              UXTB     r0,r0
;;;167    }
000026  bd10              POP      {r4,pc}
;;;168    
                          ENDP


                          AREA ||i.USBH_InterruptReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_InterruptReceiveData PROC
;;;310      */
;;;311    USBH_Status USBH_InterruptReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;312                                    uint8_t *buff, 
;;;313                                    uint8_t length,
;;;314                                    uint8_t hc_num)
;;;315    {
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;316    
;;;317      pdev->host.hc[hc_num].ep_is_in = 1;  
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  2301              MOVS     r3,#1
00000c  f88433ae          STRB     r3,[r4,#0x3ae]
000010  e9c4c2ee          STRD     r12,r2,[r4,#0x3b8]
;;;318      pdev->host.hc[hc_num].xfer_buff = buff;
;;;319      pdev->host.hc[hc_num].xfer_len = length;
;;;320      
;;;321    
;;;322      
;;;323      if(pdev->host.hc[hc_num].toggle_in == 0)
000014  f89423c4          LDRB     r2,[r4,#0x3c4]
000018  b152              CBZ      r2,|L7.48|
;;;324      {
;;;325        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
;;;326      }
;;;327      else
;;;328      {
;;;329        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
00001a  2302              MOVS     r3,#2
                  |L7.28|
00001c  f88433b4          STRB     r3,[r4,#0x3b4]
;;;330      }
;;;331    
;;;332      /* toggle DATA PID */
;;;333      pdev->host.hc[hc_num].toggle_in ^= 1;  
000020  f0820201          EOR      r2,r2,#1
000024  f88423c4          STRB     r2,[r4,#0x3c4]
;;;334      
;;;335      HCD_SubmitRequest (pdev , hc_num);  
000028  f7fffffe          BL       HCD_SubmitRequest
;;;336      
;;;337      return USBH_OK;
00002c  2000              MOVS     r0,#0
;;;338    }
00002e  bd10              POP      {r4,pc}
                  |L7.48|
000030  2300              MOVS     r3,#0                 ;325
000032  e7f3              B        |L7.28|
;;;339    
                          ENDP


                          AREA ||i.USBH_InterruptSendData||, CODE, READONLY, ALIGN=1

                  USBH_InterruptSendData PROC
;;;348      */
;;;349    USBH_Status USBH_InterruptSendData( USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;350                                    uint8_t *buff, 
;;;351                                    uint8_t length,
;;;352                                    uint8_t hc_num)
;;;353    {
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;354    
;;;355      pdev->host.hc[hc_num].ep_is_in = 0;  
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  2300              MOVS     r3,#0
00000c  f88433ae          STRB     r3,[r4,#0x3ae]
000010  e9c4c2ee          STRD     r12,r2,[r4,#0x3b8]
;;;356      pdev->host.hc[hc_num].xfer_buff = buff;
;;;357      pdev->host.hc[hc_num].xfer_len = length;
;;;358      
;;;359      if(pdev->host.hc[hc_num].toggle_in == 0)
000014  f89423c4          LDRB     r2,[r4,#0x3c4]
000018  b102              CBZ      r2,|L8.28|
;;;360      {
;;;361        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
;;;362      }
;;;363      else
;;;364      {
;;;365        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
00001a  2302              MOVS     r3,#2
                  |L8.28|
00001c  f88433b4          STRB     r3,[r4,#0x3b4]        ;361
;;;366      }
;;;367    
;;;368      pdev->host.hc[hc_num].toggle_in ^= 1;  
000020  f0820201          EOR      r2,r2,#1
000024  f88423c4          STRB     r2,[r4,#0x3c4]
;;;369      
;;;370      HCD_SubmitRequest (pdev , hc_num);  
000028  f7fffffe          BL       HCD_SubmitRequest
;;;371      
;;;372      return USBH_OK;
00002c  2000              MOVS     r0,#0
;;;373    }
00002e  bd10              POP      {r4,pc}
;;;374    
                          ENDP


                          AREA ||i.USBH_IsocReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_IsocReceiveData PROC
;;;412      */
;;;413    USBH_Status USBH_IsocReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;414                                    uint8_t *buff, 
;;;415                                    uint32_t length,
;;;416                                    uint8_t hc_num)
;;;417    {    
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;418      
;;;419      pdev->host.hc[hc_num].ep_is_in = 1;  
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  f504746b          ADD      r4,r4,#0x3ac
00000e  2301              MOVS     r3,#1
000010  70a3              STRB     r3,[r4,#2]
000012  e9c4c203          STRD     r12,r2,[r4,#0xc]
;;;420      pdev->host.hc[hc_num].xfer_buff = buff;
;;;421      pdev->host.hc[hc_num].xfer_len = length;
;;;422      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
000016  f04f0200          MOV      r2,#0
00001a  7222              STRB     r2,[r4,#8]
;;;423      
;;;424    
;;;425      HCD_SubmitRequest (pdev , hc_num);  
00001c  f7fffffe          BL       HCD_SubmitRequest
;;;426      
;;;427      return USBH_OK;
000020  2000              MOVS     r0,#0
;;;428    }
000022  bd10              POP      {r4,pc}
;;;429    
                          ENDP


                          AREA ||i.USBH_IsocSendData||, CODE, READONLY, ALIGN=1

                  USBH_IsocSendData PROC
;;;438      */
;;;439    USBH_Status USBH_IsocSendData( USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;440                                    uint8_t *buff, 
;;;441                                    uint32_t length,
;;;442                                    uint8_t hc_num)
;;;443    {
000002  468c              MOV      r12,r1
000004  4619              MOV      r1,r3
;;;444      
;;;445      pdev->host.hc[hc_num].ep_is_in = 0;  
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  f504746b          ADD      r4,r4,#0x3ac
00000e  2300              MOVS     r3,#0
000010  70a3              STRB     r3,[r4,#2]
000012  e9c4c203          STRD     r12,r2,[r4,#0xc]
;;;446      pdev->host.hc[hc_num].xfer_buff = buff;
;;;447      pdev->host.hc[hc_num].xfer_len = length;
;;;448      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
000016  7223              STRB     r3,[r4,#8]
;;;449      
;;;450      HCD_SubmitRequest (pdev , hc_num);  
000018  f7fffffe          BL       HCD_SubmitRequest
;;;451      
;;;452      return USBH_OK;
00001c  2000              MOVS     r0,#0
;;;453    }
00001e  bd10              POP      {r4,pc}
;;;454    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_HOST_Library\\Core\\src\\usbh_ioreq.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_usbh_ioreq_c_4b12c4a6____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_usbh_ioreq_c_4b12c4a6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_usbh_ioreq_c_4b12c4a6____REVSH|
#line 128
|__asm___12_usbh_ioreq_c_4b12c4a6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
