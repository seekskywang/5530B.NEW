; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\stm32f4xx_it.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\stm32f4xx_it.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\stm32f4xx_it.crf ..\User\stm32f4xx_it.c]
                          THUMB

                          AREA ||i.BEBufToUint16||, CODE, READONLY, ALIGN=1

                  BEBufToUint16 PROC
;;;240    */
;;;241    uint16_t BEBufToUint16(uint8_t *_pBuf)
000000  7841              LDRB     r1,[r0,#1]
;;;242    {
;;;243        return (((uint16_t)_pBuf[0] << 8) | _pBuf[1]);
000002  7800              LDRB     r0,[r0,#0]
000004  ea412000          ORR      r0,r1,r0,LSL #8
;;;244    }
000008  4770              BX       lr
;;;245    
                          ENDP


                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
                  |L2.0|
;;;108      */
;;;109    void BusFault_Handler(void)
000000  e7fe              B        |L2.0|
;;;110    {
;;;111      /* Go to infinite loop when Bus Fault exception occurs */
;;;112      while (1)
;;;113      {
;;;114      }
;;;115    }
;;;116    
                          ENDP


                          AREA ||i.CRC16||, CODE, READONLY, ALIGN=2

                  CRC16 PROC
;;;638    
;;;639    uint16_t CRC16(uint8_t *_pBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;640    {    
;;;641        uint8_t ucCRCHi = 0xFF; /* 高CRC字节初始化 */
000002  22ff              MOVS     r2,#0xff
;;;642    	uint8_t ucCRCLo = 0xFF; /* 低CRC 字节初始化 */
000004  23ff              MOVS     r3,#0xff
;;;643    	uint16_t usIndex;  /* CRC循环中的索引 */
;;;644    
;;;645        while (_usLen--)
;;;646        {
;;;647    		usIndex = ucCRCHi ^ *_pBuf++; /* 计算CRC */
;;;648    		ucCRCHi = ucCRCLo ^ s_CRCHi[usIndex];
000006  4c0a              LDR      r4,|L3.48|
;;;649    		ucCRCLo = s_CRCLo[usIndex];
000008  f5047580          ADD      r5,r4,#0x100
00000c  e008              B        |L3.32|
                  |L3.14|
00000e  f810cb01          LDRB     r12,[r0],#1           ;647
000012  ea8c0c02          EOR      r12,r12,r2            ;647
000016  f814200c          LDRB     r2,[r4,r12]           ;648
00001a  405a              EORS     r2,r2,r3              ;648
00001c  f815300c          LDRB     r3,[r5,r12]
                  |L3.32|
000020  000e              MOVS     r6,r1                 ;645
000022  f1a10101          SUB      r1,r1,#1              ;645
000026  b289              UXTH     r1,r1                 ;645
000028  d1f1              BNE      |L3.14|
;;;650        }
;;;651        return ((uint16_t)ucCRCHi << 8 | ucCRCLo);
00002a  ea432002          ORR      r0,r3,r2,LSL #8
;;;652    }
00002e  bd70              POP      {r4-r6,pc}
;;;653    
                          ENDP

                  |L3.48|
                          DCD      ||.constdata||

                          AREA ||i.DMA2_Stream0_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Stream0_IRQHandler PROC
;;;318    
;;;319    void  DMA2_Stream0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;320    {
;;;321    	DMA_ClearITPendingBit(DMA2_Stream0,DMA_IT_TCIF0);
000002  4905              LDR      r1,|L4.24|
000004  4805              LDR      r0,|L4.28|
000006  f7fffffe          BL       DMA_ClearITPendingBit
;;;322    	Flag_ADC_Full=1;
00000a  4805              LDR      r0,|L4.32|
00000c  6801              LDR      r1,[r0,#0]  ; flagA
00000e  f0410102          ORR      r1,r1,#2
000012  6001              STR      r1,[r0,#0]  ; flagA
;;;323    }
000014  bd10              POP      {r4,pc}
;;;324    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x10008020
                  |L4.28|
                          DCD      0x40026410
                  |L4.32|
                          DCD      flagA

                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;143      */
;;;144    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;145    {
;;;146    }
;;;147    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L6.0|
;;;82       */
;;;83     void HardFault_Handler(void)
000000  e7fe              B        |L6.0|
;;;84     {
;;;85       /* Go to infinite loop when Hard Fault exception occurs */
;;;86       while (1)
;;;87       {
;;;88       }
;;;89     }
;;;90     
                          ENDP


                          AREA ||i.MODS_03H||, CODE, READONLY, ALIGN=2

                  MODS_03H PROC
;;;511    
;;;512    static void MODS_03H(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;513    {
000004  b090              SUB      sp,sp,#0x40
;;;514        uint16_t reg;
;;;515    	uint16_t num;
;;;516    	uint16_t i;
;;;517    	uint8_t reg_value[64];
;;;518    
;;;519        
;;;520        g_tModS.RspCode = RSP_OK;
000006  4f2c              LDR      r7,|L7.184|
000008  2000              MOVS     r0,#0
00000a  f88700a1          STRB     r0,[r7,#0xa1]
;;;521    
;;;522    	if (g_tModS.RxCount != 8)								/* 03H命令必须是8个字节 */
00000e  f897009e          LDRB     r0,[r7,#0x9e]  ; g_tModS
;;;523    	{
;;;524    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000012  f04f0903          MOV      r9,#3
;;;525    		goto err_ret;
;;;526    	}
;;;527    
;;;528    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 				/* 寄存器号 */
;;;529    	num = BEBufToUint16(&g_tModS.RxBuf[4]);					/* 寄存器个数 */
;;;530    	if (num > sizeof(reg_value) / 2)
;;;531    	{
;;;532    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
;;;533    		goto err_ret;
;;;534    	}
;;;535    
;;;536    	for (i = 0; i < num; i++)
;;;537    	{
;;;538    		if (MODS_ReadRegValue(reg, &reg_value[2 * i]) == 0)	/* 读出寄存器值放入reg_value */
;;;539    		{
;;;540    			g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
000016  f04f0a02          MOV      r10,#2
00001a  46e8              MOV      r8,sp                 ;517
00001c  2808              CMP      r0,#8                 ;522
00001e  d002              BEQ      |L7.38|
000020  f88790a1          STRB     r9,[r7,#0xa1]         ;524
000024  e01a              B        |L7.92|
                  |L7.38|
000026  1cb8              ADDS     r0,r7,#2              ;528
000028  f7fffffe          BL       BEBufToUint16
00002c  4606              MOV      r6,r0                 ;528
00002e  1d38              ADDS     r0,r7,#4              ;529
000030  f7fffffe          BL       BEBufToUint16
000034  4605              MOV      r5,r0                 ;529
000036  2d20              CMP      r5,#0x20              ;530
000038  d902              BLS      |L7.64|
00003a  f88790a1          STRB     r9,[r7,#0xa1]         ;532
00003e  e00d              B        |L7.92|
                  |L7.64|
000040  2400              MOVS     r4,#0                 ;536
000042  e009              B        |L7.88|
                  |L7.68|
000044  eb080144          ADD      r1,r8,r4,LSL #1       ;538
000048  4630              MOV      r0,r6                 ;538
00004a  f7fffffe          BL       MODS_ReadRegValue
00004e  b1a8              CBZ      r0,|L7.124|
;;;541    			break;
;;;542    		}
;;;543    		reg++;
000050  1c76              ADDS     r6,r6,#1
000052  b2b6              UXTH     r6,r6
000054  1c64              ADDS     r4,r4,#1              ;536
000056  b2a4              UXTH     r4,r4                 ;536
                  |L7.88|
000058  42ac              CMP      r4,r5                 ;536
00005a  d3f3              BCC      |L7.68|
                  |L7.92|
;;;544    	}
;;;545    
;;;546    err_ret:
;;;547    	if (g_tModS.RspCode == RSP_OK)							/* 正确应答 */
00005c  f89700a1          LDRB     r0,[r7,#0xa1]  ; g_tModS
000060  2800              CMP      r0,#0
000062  d125              BNE      |L7.176|
;;;548    	{
;;;549    		g_tModS.TxCount = 0;
;;;550    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
000064  7838              LDRB     r0,[r7,#0]  ; g_tModS
000066  77b8              STRB     r0,[r7,#0x1e]
;;;551    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
000068  4913              LDR      r1,|L7.184|
00006a  7878              LDRB     r0,[r7,#1]  ; g_tModS
00006c  77c8              STRB     r0,[r1,#0x1f]
;;;552    		g_tModS.TxBuf[g_tModS.TxCount++] = num * 2;			/* 返回字节数 */
00006e  0068              LSLS     r0,r5,#1
000070  f88790a2          STRB     r9,[r7,#0xa2]
000074  f8810020          STRB     r0,[r1,#0x20]
;;;553    
;;;554    		for (i = 0; i < num; i++)
000078  2000              MOVS     r0,#0
00007a  e017              B        |L7.172|
                  |L7.124|
00007c  f887a0a1          STRB     r10,[r7,#0xa1]        ;540
000080  e7ec              B        |L7.92|
                  |L7.130|
;;;555    		{
;;;556    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i];
000082  f89710a2          LDRB     r1,[r7,#0xa2]  ; g_tModS
000086  f8183010          LDRB     r3,[r8,r0,LSL #1]
00008a  1c4a              ADDS     r2,r1,#1
00008c  4439              ADD      r1,r1,r7
00008e  f88720a2          STRB     r2,[r7,#0xa2]
000092  778b              STRB     r3,[r1,#0x1e]
;;;557    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i+1];
000094  eb080140          ADD      r1,r8,r0,LSL #1
000098  784b              LDRB     r3,[r1,#1]
00009a  f89710a2          LDRB     r1,[r7,#0xa2]  ; g_tModS
00009e  1c4a              ADDS     r2,r1,#1
0000a0  4439              ADD      r1,r1,r7
0000a2  f88720a2          STRB     r2,[r7,#0xa2]
0000a6  778b              STRB     r3,[r1,#0x1e]
0000a8  1c40              ADDS     r0,r0,#1              ;554
0000aa  b280              UXTH     r0,r0                 ;554
                  |L7.172|
0000ac  42a8              CMP      r0,r5                 ;554
0000ae  d3e8              BCC      |L7.130|
                  |L7.176|
;;;558    		}
;;;559    //         if(usartocflag == 0)
;;;560    //         {
;;;561    //             MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);	/* 发送正确应答 */
;;;562    //         }
;;;563    	}
;;;564    	else
;;;565    	{
;;;566    //		MODS_SendAckErr(g_tModS.RspCode);					/* 发送错误应答 */
;;;567    	}
;;;568        
;;;569    }
0000b0  b010              ADD      sp,sp,#0x40
0000b2  e8bd87f0          POP      {r4-r10,pc}
;;;570    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L7.184|
                          DCD      ||.bss||

                          AREA ||i.MODS_06H||, CODE, READONLY, ALIGN=2

                  MODS_06H PROC
;;;590    
;;;591    static void MODS_06H(void)
000000  b510              PUSH     {r4,lr}
;;;592    {
;;;593        uint16_t reg;
;;;594    	uint16_t value;
;;;595    
;;;596    	g_tModS.RspCode = RSP_OK;
000002  4a16              LDR      r2,|L8.92|
000004  2000              MOVS     r0,#0
000006  f88200a1          STRB     r0,[r2,#0xa1]
;;;597    
;;;598    	if (g_tModS.RxCount != 8)
00000a  f892009e          LDRB     r0,[r2,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d003              BEQ      |L8.26|
;;;599    	{
;;;600    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000012  2003              MOVS     r0,#3
000014  f88200a1          STRB     r0,[r2,#0xa1]
                  |L8.24|
;;;601    		goto err_ret;
;;;602    	}
;;;603    
;;;604    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
;;;605    	value = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 寄存器值 */
;;;606        
;;;607        if(reg == 0x0E)
;;;608        {
;;;609            if(value == 00)
;;;610            {
;;;611                GPIO_ResetBits(GPIOC,GPIO_Pin_10);//CC
;;;612                flag_Load_CC = 1;
;;;613            }else if(value == 01){
;;;614                GPIO_SetBits(GPIOC,GPIO_Pin_10);//CV
;;;615                flag_Load_CC = 0;
;;;616            }
;;;617        }
;;;618    // 	if (MODS_WriteRegValue(reg, value) == 1)	/* 该函数会把写入的值存入寄存器 */
;;;619    // 	{
;;;620    // 		;
;;;621    // 	}
;;;622    // 	else
;;;623    // 	{
;;;624    // 		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
;;;625    // 	}
;;;626    
;;;627    err_ret:
;;;628    	if (g_tModS.RspCode == RSP_OK)				/* 正确应答 */
;;;629    	{
;;;630    //		MODS_SendAckOk();
;;;631    	}
;;;632    	else
;;;633    	{
;;;634    //		MODS_SendAckErr(g_tModS.RspCode);		/* 告诉主机命令错误 */
;;;635    	}
;;;636    }
000018  bd10              POP      {r4,pc}
                  |L8.26|
00001a  1c90              ADDS     r0,r2,#2              ;604
00001c  f7fffffe          BL       BEBufToUint16
000020  4603              MOV      r3,r0                 ;604
000022  1d10              ADDS     r0,r2,#4              ;605
000024  f7fffffe          BL       BEBufToUint16
000028  2b0e              CMP      r3,#0xe               ;607
00002a  d1f5              BNE      |L8.24|
00002c  4a0c              LDR      r2,|L8.96|
00002e  4c0d              LDR      r4,|L8.100|
000030  f44f6180          MOV      r1,#0x400             ;611
000034  b148              CBZ      r0,|L8.74|
000036  2801              CMP      r0,#1                 ;613
000038  d1ee              BNE      |L8.24|
00003a  4610              MOV      r0,r2                 ;614
00003c  f7fffffe          BL       GPIO_SetBits
000040  6820              LDR      r0,[r4,#0]            ;615  ; flagD
000042  f0200080          BIC      r0,r0,#0x80           ;615
000046  6020              STR      r0,[r4,#0]            ;615  ; flagD
000048  bd10              POP      {r4,pc}
                  |L8.74|
00004a  4610              MOV      r0,r2                 ;611
00004c  f7fffffe          BL       GPIO_ResetBits
000050  6820              LDR      r0,[r4,#0]            ;612  ; flagD
000052  f0400080          ORR      r0,r0,#0x80           ;612
000056  6020              STR      r0,[r4,#0]            ;612  ; flagD
000058  bd10              POP      {r4,pc}
;;;637    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      ||.bss||
                  |L8.96|
                          DCD      0x40020800
                  |L8.100|
                          DCD      flagD

                          AREA ||i.MODS_ReadRegValue||, CODE, READONLY, ALIGN=2

                  MODS_ReadRegValue PROC
;;;426    */
;;;427    static uint8_t MODS_ReadRegValue(uint16_t reg_addr, uint8_t *reg_value)
000000  b570              PUSH     {r4-r6,lr}
;;;428    {
000002  460c              MOV      r4,r1
000004  ed2d8b02          VPUSH    {d8}
;;;429        uint16_t value;
;;;430    	lock = 1;
000008  2601              MOVS     r6,#1
00000a  4949              LDR      r1,|L9.304|
00000c  700e              STRB     r6,[r1,#0]
;;;431    	switch (reg_addr)									/* 判断寄存器地址 */
;;;432    	{
;;;433            case SLAVE_REG_P00:
;;;434    			value =	R_VLUE;	
00000e  4d49              LDR      r5,|L9.308|
;;;435    			break;
;;;436    		case SLAVE_REG_P01:
;;;437                shortv = DISS_Voltage;
;;;438    			value =	(int)(DISS_Voltage*1000);	
000010  ed9f8a49          VLDR     s16,|L9.312|
000014  2813              CMP      r0,#0x13              ;431
000016  d26e              BCS      |L9.246|
000018  e8dff000          TBB      [pc,r0]               ;431
00001c  0a0d1b26          DCB      0x0a,0x0d,0x1b,0x26
000020  333e5052          DCB      0x33,0x3e,0x50,0x52
000024  5456585a          DCB      0x54,0x56,0x58,0x5a
000028  6365676e          DCB      0x63,0x65,0x67,0x6e
00002c  72767d00          DCB      0x72,0x76,0x7d,0x00
000030  6b68              LDR      r0,[r5,#0x34]         ;434  ; Run_Control
000032  b280              UXTH     r0,r0                 ;434
000034  e072              B        |L9.284|
000036  4841              LDR      r0,|L9.316|
000038  ed900a00          VLDR     s0,[r0,#0]            ;437
00003c  4840              LDR      r0,|L9.320|
00003e  ed800a00          VSTR     s0,[r0,#0]            ;437
000042  ee200a08          VMUL.F32 s0,s0,s16
000046  eebd0ac0          VCVT.S32.F32 s0,s0
00004a  ee100a10          VMOV     r0,s0
00004e  b280              UXTH     r0,r0
;;;439    			break;
000050  e064              B        |L9.284|
;;;440    
;;;441    		case SLAVE_REG_P02:
;;;442    			value =	(int)(DISS_Current*1000);       /* 将寄存器值读出 */
000052  483c              LDR      r0,|L9.324|
000054  ed900a00          VLDR     s0,[r0,#0]
000058  ee200a08          VMUL.F32 s0,s0,s16
00005c  eebd0ac0          VCVT.S32.F32 s0,s0
000060  ee100a10          VMOV     r0,s0
000064  b280              UXTH     r0,r0
;;;443    			break;
000066  e059              B        |L9.284|
;;;444    		case SLAVE_REG_P03: 
;;;445    			value =	(int)(DISS_POW_Voltage*100);	
000068  4837              LDR      r0,|L9.328|
00006a  eddf0a38          VLDR     s1,|L9.332|
00006e  ed900a00          VLDR     s0,[r0,#0]
000072  ee200a20          VMUL.F32 s0,s0,s1
000076  eebd0ac0          VCVT.S32.F32 s0,s0
00007a  ee100a10          VMOV     r0,s0
00007e  b280              UXTH     r0,r0
;;;446    			break;
000080  e04c              B        |L9.284|
;;;447    
;;;448    		case SLAVE_REG_P04:
;;;449    			value =	(int)(DISS_POW_Current*1000);		/* 将寄存器值读出 */
000082  4833              LDR      r0,|L9.336|
000084  ed900a00          VLDR     s0,[r0,#0]
000088  ee200a08          VMUL.F32 s0,s0,s16
00008c  eebd0ac0          VCVT.S32.F32 s0,s0
000090  ee100a10          VMOV     r0,s0
000094  b280              UXTH     r0,r0
;;;450    			break;
000096  e041              B        |L9.284|
;;;451    		case SLAVE_REG_P05:
;;;452    			IO_OFF();
000098  f7fffffe          BL       IO_OFF
;;;453                SET_Current_Laod = 1000;
00009c  f44f707a          MOV      r0,#0x3e8
0000a0  6128              STR      r0,[r5,#0x10]  ; Run_Control
;;;454                usartocflag = 1; 
0000a2  482c              LDR      r0,|L9.340|
0000a4  7006              STRB     r6,[r0,#0]
;;;455    //            while(usartocflag == 1);
;;;456                value = (int)(oc_data*1000);
0000a6  482c              LDR      r0,|L9.344|
0000a8  ed900a00          VLDR     s0,[r0,#0]
0000ac  ee200a08          VMUL.F32 s0,s0,s16
0000b0  eebd0ac0          VCVT.S32.F32 s0,s0
0000b4  ee100a10          VMOV     r0,s0
0000b8  b280              UXTH     r0,r0
;;;457    			break;
0000ba  e02f              B        |L9.284|
;;;458    		case SLAVE_REG_P06:
;;;459    			value = 0;							/* 将寄存器值读出 */
0000bc  2000              MOVS     r0,#0
;;;460    			break;
0000be  e02d              B        |L9.284|
;;;461    		case SLAVE_REG_P07:
;;;462    			value =	0;							/* 将寄存器值读出 */
0000c0  2000              MOVS     r0,#0
;;;463    			break;
0000c2  e02b              B        |L9.284|
;;;464    		case SLAVE_REG_P08:
;;;465    			value =	0;	
0000c4  2000              MOVS     r0,#0
;;;466    			break;
0000c6  e029              B        |L9.284|
;;;467    
;;;468    		case SLAVE_REG_P09:
;;;469    			value =	0;							/* 将寄存器值读出 */
0000c8  2000              MOVS     r0,#0
;;;470    			break;
0000ca  e027              B        |L9.284|
;;;471    		case SLAVE_REG_P10:
;;;472    			value =	0;	
0000cc  2000              MOVS     r0,#0
;;;473    			break;
0000ce  e025              B        |L9.284|
;;;474    
;;;475    		case SLAVE_REG_P11:
;;;476    			value =	(int)temp;							/* 将寄存器值读出 */
0000d0  4822              LDR      r0,|L9.348|
0000d2  ed900a02          VLDR     s0,[r0,#8]
0000d6  eebd0ac0          VCVT.S32.F32 s0,s0
0000da  ee100a10          VMOV     r0,s0
0000de  b280              UXTH     r0,r0
;;;477    			break;
0000e0  e01c              B        |L9.284|
;;;478    		case SLAVE_REG_P12:
;;;479    			value =	0;	
0000e2  2000              MOVS     r0,#0
;;;480    			break;
0000e4  e01a              B        |L9.284|
;;;481    
;;;482    		case SLAVE_REG_P13:
;;;483    			value =	0;							/* 将寄存器值读出 */
0000e6  2000              MOVS     r0,#0
;;;484    			break;
0000e8  e018              B        |L9.284|
;;;485    		case SLAVE_REG_P14:
;;;486    			value =	!flag_Load_CC;	
0000ea  481d              LDR      r0,|L9.352|
0000ec  6800              LDR      r0,[r0,#0]  ; flagD
0000ee  f34010c0          SBFX     r0,r0,#7,#1
0000f2  1c40              ADDS     r0,r0,#1
;;;487    			break;
0000f4  e012              B        |L9.284|
                  |L9.246|
0000f6  e018              B        |L9.298|
;;;488    
;;;489    		case SLAVE_REG_P15:
;;;490    			value =	load_v;							/* 将寄存器值读出 */
0000f8  f8d500a4          LDR      r0,[r5,#0xa4]  ; Run_Control
0000fc  b280              UXTH     r0,r0
;;;491    			break;
0000fe  e00d              B        |L9.284|
;;;492    		case SLAVE_REG_P16:
;;;493    			value =	load_c;	
000100  f8d50094          LDR      r0,[r5,#0x94]  ; Run_Control
000104  b280              UXTH     r0,r0
;;;494    			break;
000106  e009              B        |L9.284|
;;;495    
;;;496    		case SLAVE_REG_P17:
;;;497    			value =	pow_v*10;							/* 将寄存器值读出 */
000108  f8d50098          LDR      r0,[r5,#0x98]  ; Run_Control
00010c  eb000080          ADD      r0,r0,r0,LSL #2
000110  0440              LSLS     r0,r0,#17
000112  0c00              LSRS     r0,r0,#16
;;;498    			break;
000114  e002              B        |L9.284|
;;;499    		case SLAVE_REG_P18:
;;;500    			value =	pow_c;							/* 将寄存器值读出 */
000116  f8d500a0          LDR      r0,[r5,#0xa0]  ; Run_Control
00011a  b280              UXTH     r0,r0
                  |L9.284|
;;;501    			break;	
;;;502    		default:
;;;503    			return 0;
;;;504        }
;;;505    	reg_value[0] = value >> 8;
00011c  0a01              LSRS     r1,r0,#8
00011e  7021              STRB     r1,[r4,#0]
;;;506    	reg_value[1] = value;
000120  7060              STRB     r0,[r4,#1]
;;;507    
;;;508    	return 1;											/* 读取成功 */
000122  2001              MOVS     r0,#1
                  |L9.292|
;;;509    }
000124  ecbd8b02          VPOP     {d8}
000128  bd70              POP      {r4-r6,pc}
                  |L9.298|
00012a  2000              MOVS     r0,#0                 ;503
00012c  e7fa              B        |L9.292|
;;;510    
                          ENDP

00012e  0000              DCW      0x0000
                  |L9.304|
                          DCD      lock
                  |L9.308|
                          DCD      Run_Control
                  |L9.312|
000138  447a0000          DCFS     0x447a0000 ; 1000
                  |L9.316|
                          DCD      DISS_Voltage
                  |L9.320|
                          DCD      shortv
                  |L9.324|
                          DCD      DISS_Current
                  |L9.328|
                          DCD      DISS_POW_Voltage
                  |L9.332|
00014c  42c80000          DCFS     0x42c80000 ; 100
                  |L9.336|
                          DCD      DISS_POW_Current
                  |L9.340|
                          DCD      usartocflag
                  |L9.344|
                          DCD      oc_data
                  |L9.348|
                          DCD      ||.data||
                  |L9.352|
                          DCD      flagD

                          AREA ||i.MODS_SendWithCRC||, CODE, READONLY, ALIGN=1

                  MODS_SendWithCRC PROC
;;;571    
;;;572    void MODS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
000000  b530              PUSH     {r4,r5,lr}
;;;573    {
000002  b0a1              SUB      sp,sp,#0x84
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;574    	uint16_t crc;
;;;575    	uint8_t buf[S_TX_BUF_SIZE];
;;;576    	memcpy(buf, _pBuf, _ucLen);
000008  4622              MOV      r2,r4
00000a  4629              MOV      r1,r5
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       __aeabi_memcpy
;;;577    	crc = CRC16(_pBuf, _ucLen);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       CRC16
;;;578    	buf[_ucLen++] = crc >> 8;
00001a  0a05              LSRS     r5,r0,#8
00001c  ab01              ADD      r3,sp,#4
00001e  1c61              ADDS     r1,r4,#1
000020  b2ca              UXTB     r2,r1
000022  551d              STRB     r5,[r3,r4]
;;;579    	buf[_ucLen++] = crc;
000024  1c51              ADDS     r1,r2,#1
000026  b2c9              UXTB     r1,r1
000028  5498              STRB     r0,[r3,r2]
;;;580    //通过485发数据
;;;581    //	RS485_SendBuf(buf, _ucLen);
;;;582    
;;;583    	uart1SendChars(buf, _ucLen);
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       uart1SendChars
;;;584    	
;;;585    // #if 1									/* 此部分为了串口打印结果,实际运用中可不要 */
;;;586    // 	g_tPrint.Txlen = _ucLen;
;;;587    // 	memcpy(g_tPrint.TxBuf, buf, _ucLen);
;;;588    // #endif
;;;589    }
000030  b021              ADD      sp,sp,#0x84
000032  bd30              POP      {r4,r5,pc}
;;;590    
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
                  |L11.0|
;;;95       */
;;;96     void MemManage_Handler(void)
000000  e7fe              B        |L11.0|
;;;97     {
;;;98       /* Go to infinite loop when Memory Manage exception occurs */
;;;99       while (1)
;;;100      {
;;;101      }
;;;102    }
;;;103    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;73       */
;;;74     void NMI_Handler(void)
000000  4770              BX       lr
;;;75     {
;;;76     }
;;;77     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;152      */
;;;153    void PendSV_Handler(void)
000000  4770              BX       lr
;;;154    {
;;;155    }
;;;156    
                          ENDP


                          AREA ||i.RecHandle||, CODE, READONLY, ALIGN=2

                  RecHandle PROC
;;;393    
;;;394    void RecHandle(void)
000000  4805              LDR      r0,|L14.24|
;;;395    {
;;;396        u8 crec[6];
;;;397        u8 *csend;
;;;398        static u8 *sendbuf;
;;;399        u8 sendlen;
;;;400        static u16 recrc;
;;;401        static u16 scrc;
;;;402        u8 i;
;;;403        
;;;404        switch(g_tModS.RxBuf[1])
000002  7840              LDRB     r0,[r0,#1]  ; g_tModS
000004  2803              CMP      r0,#3
000006  d003              BEQ      |L14.16|
000008  2806              CMP      r0,#6
00000a  d103              BNE      |L14.20|
;;;405        {
;;;406            case 0x03:
;;;407            {
;;;408                MODS_03H();
;;;409            }break;
;;;410            case 0x06:
;;;411            {
;;;412                MODS_06H();
00000c  f7ffbffe          B.W      MODS_06H
                  |L14.16|
000010  f7ffbffe          B.W      MODS_03H
                  |L14.20|
;;;413            }break;
;;;414            default:break;
;;;415        }
;;;416    }
000014  4770              BX       lr
;;;417    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      ||.bss||

                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;134      */
;;;135    void SVC_Handler(void)
000000  4770              BX       lr
;;;136    {
;;;137    }
;;;138    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;161      */
;;;162    void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;163    {
;;;164    	TimingDelay_Decrement();
000002  f7fffffe          BL       TimingDelay_Decrement
;;;165    	OS_TimeMS++;
000006  4918              LDR      r1,|L16.104|
000008  6808              LDR      r0,[r1,#0]  ; OS_TimeMS
00000a  1c40              ADDS     r0,r0,#1
00000c  6008              STR      r0,[r1,#0]  ; OS_TimeMS
;;;166    	t_KeyScan++;
00000e  4817              LDR      r0,|L16.108|
000010  7801              LDRB     r1,[r0,#0]  ; t_KeyScan
000012  1c49              ADDS     r1,r1,#1
000014  7001              STRB     r1,[r0,#0]
;;;167    	if(t_KeyScan>10)
000016  7803              LDRB     r3,[r0,#0]  ; t_KeyScan
;;;168    	{
;;;169    		t_KeyScan=0;
;;;170    		Flag_Key_Scan=1;//д?л???
000018  4a15              LDR      r2,|L16.112|
00001a  2100              MOVS     r1,#0                 ;169
00001c  2b0a              CMP      r3,#0xa               ;167
00001e  d904              BLS      |L16.42|
000020  7001              STRB     r1,[r0,#0]            ;169
000022  6810              LDR      r0,[r2,#0]  ; flagA
000024  f0400008          ORR      r0,r0,#8
000028  6010              STR      r0,[r2,#0]  ; flagA
                  |L16.42|
;;;171    	}
;;;172    	t_0_5S++;
00002a  4812              LDR      r0,|L16.116|
00002c  8803              LDRH     r3,[r0,#0]  ; t_0_5S
00002e  1c5b              ADDS     r3,r3,#1
000030  8003              STRH     r3,[r0,#0]
;;;173    	if(t_0_5S>20)
000032  8803              LDRH     r3,[r0,#0]  ; t_0_5S
000034  2b14              CMP      r3,#0x14
000036  d904              BLS      |L16.66|
;;;174    	{
;;;175    		t_0_5S=0;
000038  8001              STRH     r1,[r0,#0]
;;;176    		Flag_0_5S =1;//???Ь????
00003a  6810              LDR      r0,[r2,#0]  ; flagA
00003c  f0400080          ORR      r0,r0,#0x80
000040  6010              STR      r0,[r2,#0]  ; flagA
                  |L16.66|
;;;177    	}
;;;178    //--------------------------------------------
;;;179    	if(flag_Tim_USART==1)//???￡??
000042  4b0d              LDR      r3,|L16.120|
;;;180    	{
;;;181    		t_USART++;
000044  4a0d              LDR      r2,|L16.124|
000046  6818              LDR      r0,[r3,#0]            ;179  ; flagD
000048  07c4              LSLS     r4,r0,#31             ;179
00004a  d002              BEQ      |L16.82|
00004c  7814              LDRB     r4,[r2,#0]  ; t_USART
00004e  1c64              ADDS     r4,r4,#1
000050  7014              STRB     r4,[r2,#0]
                  |L16.82|
;;;182    	}
;;;183    	if(t_USART>40)//??2.6ms
000052  7814              LDRB     r4,[r2,#0]  ; t_USART
000054  2c28              CMP      r4,#0x28
000056  d905              BLS      |L16.100|
;;;184    	{
;;;185    		t_USART=0;
000058  7011              STRB     r1,[r2,#0]
;;;186    		flag_Tim_USART=0;
00005a  f0200001          BIC      r0,r0,#1
00005e  6018              STR      r0,[r3,#0]  ; flagD
;;;187    		UART_Buffer_Size=0;	
000060  4807              LDR      r0,|L16.128|
000062  7001              STRB     r1,[r0,#0]
                  |L16.100|
;;;188    	}
;;;189    }
000064  bd10              POP      {r4,pc}
;;;190    
                          ENDP

000066  0000              DCW      0x0000
                  |L16.104|
                          DCD      OS_TimeMS
                  |L16.108|
                          DCD      t_KeyScan
                  |L16.112|
                          DCD      flagA
                  |L16.116|
                          DCD      t_0_5S
                  |L16.120|
                          DCD      flagD
                  |L16.124|
                          DCD      t_USART
                  |L16.128|
                          DCD      UART_Buffer_Size

                          AREA ||i.TIM6_DAC_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM6_DAC_IRQHandler PROC
;;;324    
;;;325    void  TIM6_DAC_IRQHandler (void)
000000  2101              MOVS     r1,#1
;;;326    {
;;;327    	TIM_ClearITPendingBit(TIM6,TIM_IT_Update);//?????λ
000002  4801              LDR      r0,|L17.8|
000004  f7ffbffe          B.W      TIM_ClearITPendingBit
;;;328    }
;;;329    
                          ENDP

                  |L17.8|
                          DCD      0x40001000

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;329    
;;;330    void USART1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;331    {
;;;332    //	flag_Tim_USART=1;
;;;333        
;;;334     	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000002  4d0d              LDR      r5,|L18.56|
000004  f2405125          MOV      r1,#0x525
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d010              BEQ      |L18.52|
;;;335    	{
;;;336            g_mods_timeout = 2;
000012  490a              LDR      r1,|L18.60|
000014  2002              MOVS     r0,#2
000016  7008              STRB     r0,[r1,#0]
;;;337            if (g_tModS.RxCount < S_RX_BUF_SIZE)
000018  4c09              LDR      r4,|L18.64|
00001a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00001e  281e              CMP      r0,#0x1e
000020  d208              BCS      |L18.52|
;;;338            {
;;;339                g_tModS.RxBuf[g_tModS.RxCount++] = USART_ReceiveData(USART1);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USART_ReceiveData
000028  f894109e          LDRB     r1,[r4,#0x9e]  ; g_tModS
00002c  1c4a              ADDS     r2,r1,#1
00002e  f884209e          STRB     r2,[r4,#0x9e]
000032  5460              STRB     r0,[r4,r1]
                  |L18.52|
;;;340            }
;;;341    	}
;;;342    }
000034  bd70              POP      {r4-r6,pc}
;;;343    
                          ENDP

000036  0000              DCW      0x0000
                  |L18.56|
                          DCD      0x40011000
                  |L18.60|
                          DCD      ||.data||
                  |L18.64|
                          DCD      ||.bss||

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;344    
;;;345    void USART3_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;346    {
000004  ed2d8b02          VPUSH    {d8}
;;;347        static vu8 count = 0;
;;;348        u8 res; 
;;;349        static vu8 i = 0;
;;;350        static float sum;
;;;351        if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
000008  f2405725          MOV      r7,#0x525
00000c  4e35              LDR      r6,|L19.228|
00000e  4639              MOV      r1,r7
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       USART_GetITStatus
000016  2800              CMP      r0,#0
000018  d05f              BEQ      |L19.218|
;;;352        {
;;;353            
;;;354            res =USART_ReceiveData(USART3);//(USART1->DR); //????????
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       USART_ReceiveData
000020  b2c2              UXTB     r2,r0
;;;355            if(count == 0)
000022  4c31              LDR      r4,|L19.232|
000024  7860              LDRB     r0,[r4,#1]  ; count
;;;356            {
;;;357                if(res == 0x03)
;;;358                {
;;;359                    count = 1;
;;;360                }else{
;;;361                    count = 0;
000026  2500              MOVS     r5,#0
000028  b178              CBZ      r0,|L19.74|
;;;362                }
;;;363            }else if(count == 1){
00002a  7860              LDRB     r0,[r4,#1]  ; count
00002c  2801              CMP      r0,#1
00002e  d013              BEQ      |L19.88|
;;;364                 if(res == 0xff)
;;;365                {
;;;366                    count = 2;
;;;367                }else{
;;;368                    count = 0;
;;;369                }
;;;370                
;;;371            }else if(count > 1 && count <4)
000030  7861              LDRB     r1,[r4,#1]  ; count
;;;372            {
;;;373                UART_Buffer_Rece[count] = res;               
000032  482e              LDR      r0,|L19.236|
000034  2901              CMP      r1,#1                 ;371
000036  d916              BLS      |L19.102|
000038  7861              LDRB     r1,[r4,#1]            ;371  ; count
00003a  2904              CMP      r1,#4                 ;371
00003c  d213              BCS      |L19.102|
00003e  7861              LDRB     r1,[r4,#1]  ; count
000040  5442              STRB     r2,[r0,r1]
;;;374    //            temp = (UART_Buffer_Rece[2] * 256 + UART_Buffer_Rece[3])/10.0;
;;;375                count ++;
000042  7860              LDRB     r0,[r4,#1]  ; count
000044  1c40              ADDS     r0,r0,#1
000046  7060              STRB     r0,[r4,#1]
000048  e03f              B        |L19.202|
                  |L19.74|
00004a  2a03              CMP      r2,#3                 ;357
00004c  d001              BEQ      |L19.82|
00004e  7065              STRB     r5,[r4,#1]            ;361
000050  e03b              B        |L19.202|
                  |L19.82|
000052  2001              MOVS     r0,#1                 ;359
000054  7060              STRB     r0,[r4,#1]            ;359
000056  e038              B        |L19.202|
                  |L19.88|
000058  2aff              CMP      r2,#0xff              ;364
00005a  d001              BEQ      |L19.96|
00005c  7065              STRB     r5,[r4,#1]            ;368
00005e  e034              B        |L19.202|
                  |L19.96|
000060  2002              MOVS     r0,#2                 ;366
000062  7060              STRB     r0,[r4,#1]            ;366
000064  e031              B        |L19.202|
                  |L19.102|
;;;376            }else if(count == 4)
000066  7861              LDRB     r1,[r4,#1]  ; count
000068  2904              CMP      r1,#4
00006a  d12e              BNE      |L19.202|
;;;377            {
;;;378                if(i < 10)
00006c  78a1              LDRB     r1,[r4,#2]  ; i
;;;379                {
;;;380                 sum += (UART_Buffer_Rece[2] * 256 + UART_Buffer_Rece[3])/10.0;
00006e  ed9f8b20          VLDR     d8,|L19.240|
000072  290a              CMP      r1,#0xa               ;378
000074  d216              BCS      |L19.164|
000076  78c1              LDRB     r1,[r0,#3]  ; UART_Buffer_Rece
000078  7880              LDRB     r0,[r0,#2]  ; UART_Buffer_Rece
00007a  eb012000          ADD      r0,r1,r0,LSL #8
00007e  f7fffffe          BL       __aeabi_ui2d
000082  ec532b18          VMOV     r2,r3,d8
000086  f7fffffe          BL       __aeabi_ddiv
00008a  ec410b18          VMOV     d8,r0,r1
00008e  6860              LDR      r0,[r4,#4]  ; sum
000090  f7fffffe          BL       __aeabi_f2d
000094  ec532b18          VMOV     r2,r3,d8
000098  f7fffffe          BL       __aeabi_dadd
00009c  f7fffffe          BL       __aeabi_d2f
0000a0  6060              STR      r0,[r4,#4]  ; sum
0000a2  e00e              B        |L19.194|
                  |L19.164|
;;;381                }else{
;;;382                    temp = sum/10.0;
0000a4  6860              LDR      r0,[r4,#4]  ; sum
0000a6  f7fffffe          BL       __aeabi_f2d
0000aa  ec532b18          VMOV     r2,r3,d8
0000ae  f7fffffe          BL       __aeabi_ddiv
0000b2  f7fffffe          BL       __aeabi_d2f
0000b6  60a0              STR      r0,[r4,#8]  ; temp
;;;383                    sum = 0;
0000b8  ed9f0a0f          VLDR     s0,|L19.248|
0000bc  ed840a01          VSTR     s0,[r4,#4]
;;;384                    i = 0;
0000c0  70a5              STRB     r5,[r4,#2]
                  |L19.194|
;;;385                }
;;;386                 count =0;
0000c2  7065              STRB     r5,[r4,#1]
;;;387                 i ++;
0000c4  78a0              LDRB     r0,[r4,#2]  ; i
0000c6  1c40              ADDS     r0,r0,#1
0000c8  70a0              STRB     r0,[r4,#2]
                  |L19.202|
;;;388            }
;;;389            USART_ClearITPendingBit(USART3, USART_IT_RXNE);
0000ca  4639              MOV      r1,r7
0000cc  ecbd8b02          VPOP     {d8}
0000d0  4630              MOV      r0,r6
0000d2  e8bd41f0          POP      {r4-r8,lr}
0000d6  f7ffbffe          B.W      USART_ClearITPendingBit
                  |L19.218|
;;;390         }
;;;391    }
0000da  ecbd8b02          VPOP     {d8}
0000de  e8bd81f0          POP      {r4-r8,pc}
;;;392    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L19.228|
                          DCD      0x40004800
                  |L19.232|
                          DCD      ||.data||
                  |L19.236|
                          DCD      UART_Buffer_Rece
                  |L19.240|
0000f0  00000000          DCFD     0x4024000000000000 ; 10
0000f4  40240000
                  |L19.248|
0000f8  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
                  |L20.0|
;;;121      */
;;;122    void UsageFault_Handler(void)
000000  e7fe              B        |L20.0|
;;;123    {
;;;124      /* Go to infinite loop when Usage Fault exception occurs */
;;;125      while (1)
;;;126      {
;;;127      }
;;;128    }
;;;129    
                          ENDP


                          AREA ||i.uart1SendChars||, CODE, READONLY, ALIGN=2

                  uart1SendChars PROC
;;;245    
;;;246    void uart1SendChars(u8 *str, u16 strlen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;247    { 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;248    	  u16 k= 0 ; 
000008  2400              MOVS     r4,#0
;;;249       do { 
;;;250           USART_SendData(USART1,*(str + k));
00000a  4f08              LDR      r7,|L21.44|
                  |L21.12|
00000c  5d29              LDRB     r1,[r5,r4]
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       USART_SendData
                  |L21.20|
;;;251           while (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);
000014  2180              MOVS     r1,#0x80
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L21.20|
;;;252           k++; 
000020  1c64              ADDS     r4,r4,#1
000022  b2a4              UXTH     r4,r4
;;;253           }   //循环发送,直到发送完毕   
;;;254        while (k < strlen); 
000024  42b4              CMP      r4,r6
000026  d3f1              BCC      |L21.12|
;;;255    } 
000028  e8bd81f0          POP      {r4-r8,pc}
;;;256    
                          ENDP

                  |L21.44|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_tModS
                          %        163

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  s_CRCHi
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  s_CRCLo
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  g_mods_timeout
000000  00                DCB      0x00
                  count
000001  00                DCB      0x00
                  i
000002  0000              DCB      0x00,0x00
                  ||sum||
                          DCD      0x00000000
                  temp
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\User\\stm32f4xx_it.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_e289a1ee____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_stm32f4xx_it_c_e289a1ee____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_e289a1ee____REVSH|
#line 128
|__asm___14_stm32f4xx_it_c_e289a1ee____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
