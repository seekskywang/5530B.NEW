; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\ssd1963.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\ssd1963.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\ssd1963.crf ..\drive\ssd1963.c]
                          THUMB

                          AREA ||i.Delay_ms||, CODE, READONLY, ALIGN=1

                  Delay_ms PROC
;;;96     }
;;;97     void  Delay_ms(vu16 mstime)
000000  b530              PUSH     {r4,r5,lr}
;;;98     {                                                           
000002  4604              MOV      r4,r0
;;;99       while (mstime--)
;;;100      {
;;;101        Delay_usS(1000);
000004  f44f757a          MOV      r5,#0x3e8
000008  e002              B        |L1.16|
                  |L1.10|
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Delay_usS
                  |L1.16|
000010  0023              MOVS     r3,r4                 ;99
000012  f1a40001          SUB      r0,r4,#1              ;99
000016  b284              UXTH     r4,r0                 ;99
000018  d1f7              BNE      |L1.10|
;;;102      }
;;;103    }
00001a  bd30              POP      {r4,r5,pc}
;;;104    void sLCD_GPIO_Config(void)
                          ENDP


                          AREA ||i.Delay_usS||, CODE, READONLY, ALIGN=1

                  Delay_usS PROC
;;;79     
;;;80     void Delay_usS(vu16 ustime)
000000  2200              MOVS     r2,#0
;;;81     {
;;;82       vu16 ii,jj;
;;;83     
;;;84       for (ii=0; ii<ustime; ++ii)
000002  e00b              B        |L2.28|
                  |L2.4|
;;;85       {
;;;86         jj=4;
000004  2104              MOVS     r1,#4
                  |L2.6|
;;;87         do
;;;88         {
;;;89           NOP;
000006  bf00              NOP      
;;;90     			NOP;
000008  bf00              NOP      
;;;91     			NOP;
00000a  bf00              NOP      
;;;92     			NOP;
00000c  bf00              NOP      
;;;93     			NOP;
00000e  bf00              NOP      
;;;94         }while (--jj);
000010  1e49              SUBS     r1,r1,#1
000012  0409              LSLS     r1,r1,#16
000014  0c09              LSRS     r1,r1,#16
000016  d1f6              BNE      |L2.6|
000018  1c52              ADDS     r2,r2,#1              ;84
00001a  b292              UXTH     r2,r2                 ;84
                  |L2.28|
00001c  4282              CMP      r2,r0                 ;84
00001e  d3f1              BCC      |L2.4|
;;;95       }
;;;96     }
000020  4770              BX       lr
;;;97     void  Delay_ms(vu16 mstime)
                          ENDP


                          AREA ||i.LCD_GetPoint||, CODE, READONLY, ALIGN=2

                  LCD_GetPoint PROC
;;;368    
;;;369    vu16 LCD_GetPoint(vu16 x, vu16 y)
000000  b500              PUSH     {lr}
;;;370    {
;;;371        vu16 temp;
;;;372        
;;;373        sLCD_OpenWindow(x, y, x, y);
000002  460b              MOV      r3,r1
000004  4602              MOV      r2,r0
000006  f7fffffe          BL       sLCD_OpenWindow
00000a  f04f41c0          MOV      r1,#0x60000000
00000e  202e              MOVS     r0,#0x2e
000010  8008              STRH     r0,[r1,#0]
000012  4801              LDR      r0,|L3.24|
000014  8800              LDRH     r0,[r0,#0]
;;;374    
;;;375        sLCD_WR_REG(0x2e);
;;;376        temp = sLCD_Read_Data();
;;;377        
;;;378    	return temp;
;;;379    }
000016  bd00              POP      {pc}
;;;380    
                          ENDP

                  |L3.24|
                          DCD      0x60020000

                          AREA ||i.LCD_Initializtion||, CODE, READONLY, ALIGN=1

                  LCD_Initializtion PROC
;;;348    
;;;349    void LCD_Initializtion(void)
000000  b510              PUSH     {r4,lr}
;;;350    {   
;;;351        sLCD_GPIO_Config();
000002  f7fffffe          BL       sLCD_GPIO_Config
;;;352        sLCD_FSMC_Config();
000006  f7fffffe          BL       sLCD_FSMC_Config
;;;353        NOP;
00000a  bf00              NOP      
;;;354    		NOP;
00000c  bf00              NOP      
;;;355    		NOP;NOP;
00000e  bf00              NOP      
000010  bf00              NOP      
;;;356    		NOP;
000012  bf00              NOP      
;;;357    		NOP;
000014  bf00              NOP      
;;;358    		NOP;
000016  bf00              NOP      
;;;359        sLCD_Init();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      sLCD_Init
;;;360    }
;;;361    
                          ENDP


                          AREA ||i.LCD_SetPoint||, CODE, READONLY, ALIGN=2

                  LCD_SetPoint PROC
;;;361    
;;;362    void LCD_SetPoint(vu16 x,vu16 y,vu16 c)
000000  b510              PUSH     {r4,lr}
;;;363    {
000002  4614              MOV      r4,r2
;;;364        sLCD_OpenWindow(x, y, x, y);
000004  460b              MOV      r3,r1
000006  4602              MOV      r2,r0
000008  f7fffffe          BL       sLCD_OpenWindow
00000c  202c              MOVS     r0,#0x2c
00000e  06c1              LSLS     r1,r0,#27
000010  8008              STRH     r0,[r1,#0]
000012  4801              LDR      r0,|L5.24|
000014  8004              STRH     r4,[r0,#0]
;;;365        sLCD_WR_REG(0x2c);
;;;366        sLCD_WR_Data(c);
;;;367    }
000016  bd10              POP      {r4,pc}
;;;368    
                          ENDP

                  |L5.24|
                          DCD      0x60020000

                          AREA ||i.sLCD_BGR2RGB||, CODE, READONLY, ALIGN=1

                  sLCD_BGR2RGB PROC
;;;66     
;;;67     vu16 sLCD_BGR2RGB(vu16 c)
000000  f3c01145          UBFX     r1,r0,#5,#6
;;;68     {
;;;69       vu16  r, g, b, rgb;
;;;70     
;;;71       b = (c>>0)  & 0x1f;
;;;72       g = (c>>5)  & 0x3f;
;;;73       r = (c>>11) & 0x1f;
000004  0ac2              LSRS     r2,r0,#11
;;;74       
;;;75       rgb =  (b<<11) + (g<<5) + (r<<0);
000006  02c0              LSLS     r0,r0,#11
000008  eb001041          ADD      r0,r0,r1,LSL #5
00000c  4410              ADD      r0,r0,r2
00000e  b280              UXTH     r0,r0
;;;76     
;;;77       return( rgb );
;;;78     }
000010  4770              BX       lr
;;;79     
                          ENDP


                          AREA ||i.sLCD_Clear||, CODE, READONLY, ALIGN=2

                  sLCD_Clear PROC
;;;209    
;;;210    void sLCD_Clear(u16 color)
000000  b530              PUSH     {r4,r5,lr}
;;;211    {
;;;212        unsigned int l=480 ,w;
;;;213        /*
;;;214    	sLCD_WR_REG(0x002A);	
;;;215    	sLCD_WR_Data(0);	    
;;;216    	sLCD_WR_Data(0);
;;;217    	sLCD_WR_Data(HDP>>8);	    
;;;218    	sLCD_WR_Data(HDP&0x00ff);
;;;219        sLCD_WR_REG(0x002b);	
;;;220    	sLCD_WR_Data(0);	    
;;;221    	sLCD_WR_Data(0);
;;;222    	sLCD_WR_Data(VDP>>8);	    
;;;223    	sLCD_WR_Data(VDP&0x00ff);
;;;224    	*/
;;;225    	sLCD_OpenWindow(0, 0, HDP, VDP);
000002  490c              LDR      r1,|L7.52|
000004  4605              MOV      r5,r0                 ;211
000006  f44f74f0          MOV      r4,#0x1e0             ;212
00000a  694b              LDR      r3,[r1,#0x14]  ; VDP
00000c  684a              LDR      r2,[r1,#4]  ; HDP
00000e  2100              MOVS     r1,#0
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       sLCD_OpenWindow
000016  202c              MOVS     r0,#0x2c
000018  06c1              LSLS     r1,r0,#27
00001a  8008              STRH     r0,[r1,#0]
00001c  4806              LDR      r0,|L7.56|
;;;226    	sLCD_WR_REG(0x002c);
;;;227        
;;;228    	while(l--)
;;;229    	{
;;;230    	    for(w=0;w<272;w++)
00001e  f44f7288          MOV      r2,#0x110
000022  e004              B        |L7.46|
                  |L7.36|
000024  2100              MOVS     r1,#0
                  |L7.38|
000026  8005              STRH     r5,[r0,#0]
000028  1c49              ADDS     r1,r1,#1
00002a  4291              CMP      r1,r2
00002c  d3fb              BCC      |L7.38|
                  |L7.46|
00002e  1e64              SUBS     r4,r4,#1              ;228
000030  d2f8              BCS      |L7.36|
;;;231    		{    
;;;232    			sLCD_WR_Data(color);
;;;233    		//  sLCD_WR_Data(color);
;;;234    		 // sLCD_WR_Data(color);
;;;235    		}
;;;236    	}
;;;237    }
000032  bd30              POP      {r4,r5,pc}
;;;238    
                          ENDP

                  |L7.52|
                          DCD      ||.data||
                  |L7.56|
                          DCD      0x60020000

                          AREA ||i.sLCD_FSMC_Config||, CODE, READONLY, ALIGN=1

                  sLCD_FSMC_Config PROC
;;;164    
;;;165     void sLCD_FSMC_Config(void)
000000  b500              PUSH     {lr}
;;;166    {		
;;;167    	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;168    	FSMC_NORSRAMTimingInitTypeDef  FSMC_NORSRAMTimingInitStructure;
;;;169    
;;;170    	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC,ENABLE);//寮FSMC堕
000002  2101              MOVS     r1,#1
000004  b08f              SUB      sp,sp,#0x3c           ;166
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;171    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;172    
;;;173    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 8;
;;;174    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;
00000c  2000              MOVS     r0,#0
;;;175    	FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 18;
;;;176    	FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
;;;177    	FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
;;;178    	FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
;;;179    	FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;
;;;180    
;;;181    	/*
;;;182    	 LCD configured as follow:
;;;183    	    - Data/Address MUX = Disable
;;;184    	    - Memory Type = SRAM
;;;185    	    - Data Width = 16bit
;;;186    	    - Write Operation = Enable
;;;187    	    - Extended Mode = Enable
;;;188    	    - Asynchronous Wait = Disable
;;;189    	*/
;;;190    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM1;//  
;;;191      FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; // 
;;;192      FSMC_NORSRAMInitStructure.FSMC_MemoryType =FSMC_MemoryType_SRAM;// FSMC_MemoryType_SRAM;  //SRAM   
;;;193      FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;//16BIT版
00000e  2110              MOVS     r1,#0x10
000010  e9cd0102          STRD     r0,r1,[sp,#8]
;;;194      FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode =FSMC_BurstAccessMode_Disable;// FSMC_BurstAccessMode_Disable; 
;;;195      FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000014  9004              STR      r0,[sp,#0x10]
;;;196    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable; 
;;;197      FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;   
;;;198      FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;  
;;;199      FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;	// 
000016  0209              LSLS     r1,r1,#8
000018  9000              STR      r0,[sp,#0]            ;191
00001a  9001              STR      r0,[sp,#4]            ;193
00001c  e9cd0108          STRD     r0,r1,[sp,#0x20]
000020  9006              STR      r0,[sp,#0x18]         ;196
000022  9005              STR      r0,[sp,#0x14]         ;197
000024  9007              STR      r0,[sp,#0x1c]
;;;200      FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;   
;;;201      FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Enable; //
000026  0089              LSLS     r1,r1,#2
000028  e9cd010a          STRD     r0,r1,[sp,#0x28]
;;;202      FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable; 
;;;203    
;;;204      FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);  //
00002c  900c              STR      r0,[sp,#0x30]
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       FSMC_NORSRAMInit
;;;205    
;;;206      FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM1, ENABLE);  //
000034  2101              MOVS     r1,#1
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       FSMC_NORSRAMCmd
;;;207    }
00003c  b00f              ADD      sp,sp,#0x3c
00003e  bd00              POP      {pc}
;;;208    
                          ENDP


                          AREA ||i.sLCD_GPIO_Config||, CODE, READONLY, ALIGN=2

                  sLCD_GPIO_Config PROC
;;;103    }
;;;104    void sLCD_GPIO_Config(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;105    {
;;;106        GPIO_InitTypeDef GPIO_InitStructure;//
;;;107        
;;;108    		GPIO_PinAFConfig(GPIOD,GPIO_PinSource7,GPIO_AF_FSMC);
000004  f8df8138          LDR      r8,|L9.320|
000008  220c              MOVS     r2,#0xc
00000a  2107              MOVS     r1,#7
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       GPIO_PinAFConfig
;;;109    		GPIO_PinAFConfig(GPIOD,GPIO_PinSource11,GPIO_AF_FSMC);
000012  220c              MOVS     r2,#0xc
000014  210b              MOVS     r1,#0xb
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       GPIO_PinAFConfig
;;;110    	
;;;111    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
00001c  220c              MOVS     r2,#0xc
00001e  2100              MOVS     r1,#0
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;112    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
000026  220c              MOVS     r2,#0xc
000028  2101              MOVS     r1,#1
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;113    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
000030  220c              MOVS     r2,#0xc
000032  2104              MOVS     r1,#4
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       GPIO_PinAFConfig
;;;114    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
00003a  220c              MOVS     r2,#0xc
00003c  2105              MOVS     r1,#5
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;115    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
000044  220c              MOVS     r2,#0xc
000046  2108              MOVS     r1,#8
000048  4640              MOV      r0,r8
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;116    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
00004e  220c              MOVS     r2,#0xc
000050  2109              MOVS     r1,#9
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;117    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
000058  220c              MOVS     r2,#0xc
00005a  210a              MOVS     r1,#0xa
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;118    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
000062  220c              MOVS     r2,#0xc
000064  210e              MOVS     r1,#0xe
000066  4640              MOV      r0,r8
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;119    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
00006c  220c              MOVS     r2,#0xc
00006e  210f              MOVS     r1,#0xf
000070  4640              MOV      r0,r8
000072  f7fffffe          BL       GPIO_PinAFConfig
;;;120    	
;;;121    
;;;122    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
000076  4f33              LDR      r7,|L9.324|
000078  220c              MOVS     r2,#0xc
00007a  2107              MOVS     r1,#7
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       GPIO_PinAFConfig
;;;123    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
000082  220c              MOVS     r2,#0xc
000084  2108              MOVS     r1,#8
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       GPIO_PinAFConfig
;;;124    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
00008c  220c              MOVS     r2,#0xc
00008e  2109              MOVS     r1,#9
000090  4638              MOV      r0,r7
000092  f7fffffe          BL       GPIO_PinAFConfig
;;;125    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
000096  220c              MOVS     r2,#0xc
000098  210a              MOVS     r1,#0xa
00009a  4638              MOV      r0,r7
00009c  f7fffffe          BL       GPIO_PinAFConfig
;;;126    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
0000a0  220c              MOVS     r2,#0xc
0000a2  210b              MOVS     r1,#0xb
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       GPIO_PinAFConfig
;;;127    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
0000aa  220c              MOVS     r2,#0xc
0000ac  4611              MOV      r1,r2
0000ae  4638              MOV      r0,r7
0000b0  f7fffffe          BL       GPIO_PinAFConfig
;;;128    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
0000b4  220c              MOVS     r2,#0xc
0000b6  210d              MOVS     r1,#0xd
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       GPIO_PinAFConfig
;;;129    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
0000be  220c              MOVS     r2,#0xc
0000c0  210e              MOVS     r1,#0xe
0000c2  4638              MOV      r0,r7
0000c4  f7fffffe          BL       GPIO_PinAFConfig
;;;130    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
0000c8  220c              MOVS     r2,#0xc
0000ca  210f              MOVS     r1,#0xf
0000cc  4638              MOV      r0,r7
0000ce  f7fffffe          BL       GPIO_PinAFConfig
;;;131        /*
;;;132            FSMC Data 管脚初始化 D0~D15
;;;133        */
;;;134        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14 | GPIO_Pin_15 | GPIO_Pin_8 | 
;;;135                                        GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_0 |
;;;136                                        GPIO_Pin_1 ;
;;;137        GPIO_InitStructure.GPIO_Speed =GPIO_Speed_100MHz;
0000d2  2503              MOVS     r5,#3
0000d4  f88d5005          STRB     r5,[sp,#5]
;;;138        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000d8  2602              MOVS     r6,#2
0000da  f24c7003          MOV      r0,#0xc703            ;134
0000de  f88d6004          STRB     r6,[sp,#4]
;;;139    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
0000e2  2400              MOVS     r4,#0
0000e4  9000              STR      r0,[sp,#0]            ;137
0000e6  f88d4006          STRB     r4,[sp,#6]
;;;140    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
0000ea  f88d4007          STRB     r4,[sp,#7]
;;;141        GPIO_Init(GPIOD, &GPIO_InitStructure);
0000ee  4669              MOV      r1,sp
0000f0  4640              MOV      r0,r8
0000f2  f7fffffe          BL       GPIO_Init
;;;142    
;;;143        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | 
;;;144                                        GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 |
;;;145                                        GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15 ;
;;;146    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
0000f6  f88d5005          STRB     r5,[sp,#5]
0000fa  f64f7080          MOV      r0,#0xff80            ;143
;;;147        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000fe  f88d6004          STRB     r6,[sp,#4]
000102  9000              STR      r0,[sp,#0]            ;146
;;;148    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000104  f88d4006          STRB     r4,[sp,#6]
;;;149    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000108  f88d4007          STRB     r4,[sp,#7]
;;;150        GPIO_Init(GPIOE, &GPIO_InitStructure);
00010c  4669              MOV      r1,sp
00010e  4638              MOV      r0,r7
000110  f7fffffe          BL       GPIO_Init
;;;151    
;;;152        /*
;;;153            CS      RD      RW      RS
;;;154        */
;;;155        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_4 | GPIO_Pin_5 |
;;;156                                        GPIO_Pin_11;
;;;157    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000114  f88d5005          STRB     r5,[sp,#5]
000118  f44f600b          MOV      r0,#0x8b0             ;155
;;;158        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00011c  f88d6004          STRB     r6,[sp,#4]
000120  9000              STR      r0,[sp,#0]            ;157
;;;159    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000122  f88d4006          STRB     r4,[sp,#6]
;;;160    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000126  f88d4007          STRB     r4,[sp,#7]
;;;161        GPIO_Init(GPIOD, &GPIO_InitStructure);
00012a  4669              MOV      r1,sp
00012c  4640              MOV      r0,r8
00012e  f7fffffe          BL       GPIO_Init
;;;162    		GPIO_ResetBits(GPIOD,GPIO_Pin_13);//RST_lcd
000132  0331              LSLS     r1,r6,#12
000134  4640              MOV      r0,r8
000136  f7fffffe          BL       GPIO_ResetBits
;;;163     }
00013a  e8bd81fc          POP      {r2-r8,pc}
;;;164    
                          ENDP

00013e  0000              DCW      0x0000
                  |L9.320|
                          DCD      0x40020c00
                  |L9.324|
                          DCD      0x40021000

                          AREA ||i.sLCD_Init||, CODE, READONLY, ALIGN=2

                  sLCD_Init PROC
;;;238    
;;;239    void sLCD_Init(void)
000000  b5f0              PUSH     {r4-r7,lr}
000002  f04f45c0          MOV      r5,#0x60000000
000006  20a1              MOVS     r0,#0xa1
000008  8028              STRH     r0,[r5,#0]
00000a  4c3c              LDR      r4,|L10.252|
00000c  8820              LDRH     r0,[r4,#0]
00000e  8820              LDRH     r0,[r4,#0]
000010  8820              LDRH     r0,[r4,#0]
000012  8820              LDRH     r0,[r4,#0]
000014  8820              LDRH     r0,[r4,#0]
000016  20e2              MOVS     r0,#0xe2
000018  8028              STRH     r0,[r5,#0]
00001a  201d              MOVS     r0,#0x1d
00001c  8020              STRH     r0,[r4,#0]
00001e  2002              MOVS     r0,#2
000020  8020              STRH     r0,[r4,#0]
000022  2004              MOVS     r0,#4
000024  8020              STRH     r0,[r4,#0]
000026  26e0              MOVS     r6,#0xe0
000028  802e              STRH     r6,[r5,#0]
00002a  2701              MOVS     r7,#1
00002c  8027              STRH     r7,[r4,#0]
;;;240    {
;;;241        vu16 DeviceCode;
;;;242        sLCD_WR_REG(0xa1);
;;;243        DeviceCode = sLCD_Read_Data();    
;;;244        DeviceCode = sLCD_Read_Data();    
;;;245        DeviceCode = sLCD_Read_Data();    
;;;246        DeviceCode = sLCD_Read_Data();    
;;;247        DeviceCode = sLCD_Read_Data();    
;;;248        DeviceCode = DeviceCode;
;;;249        //  Step 2: PLL设置
;;;250        sLCD_WR_REG(0x00E2);     //0XE2是设置PLL 的寄存器。
;;;251        sLCD_WR_Data(0x001D);// (0x002C);//   //设置倍频数 M   0x21D for 10M
;;;252        sLCD_WR_Data(0x0002);    //设置分频数 N
;;;253        sLCD_WR_Data(0x0004);    //使能MN   PLL = INCLK*(M+1) / (N+1)  PLL 倍频到120M PLL=8*44/3=120M
;;;254    
;;;255        sLCD_WR_REG(0x00E0);     //0XE0是PLL使能寄存器
;;;256        sLCD_WR_Data(0x0001);    //先开启PLL
;;;257        Delay_ms(10);
00002e  200a              MOVS     r0,#0xa
000030  f7fffffe          BL       Delay_ms
000034  802e              STRH     r6,[r5,#0]
000036  2603              MOVS     r6,#3
000038  8026              STRH     r6,[r4,#0]
;;;258    	
;;;259        sLCD_WR_REG(0x00E0);     //还要一次
;;;260        sLCD_WR_Data(0x0003);    // 使用 PLL作为时钟
;;;261        Delay_ms(10);
00003a  200a              MOVS     r0,#0xa
00003c  f7fffffe          BL       Delay_ms
000040  802f              STRH     r7,[r5,#0]
;;;262        sLCD_WR_REG(0x0001);     // 软件复位
;;;263        Delay_ms(10);
000042  200a              MOVS     r0,#0xa
000044  f7fffffe          BL       Delay_ms
000048  20e6              MOVS     r0,#0xe6
00004a  8028              STRH     r0,[r5,#0]
00004c  8027              STRH     r7,[r4,#0]
00004e  2093              MOVS     r0,#0x93
000050  8020              STRH     r0,[r4,#0]
000052  2032              MOVS     r0,#0x32
000054  8020              STRH     r0,[r4,#0]
000056  20b0              MOVS     r0,#0xb0
000058  8028              STRH     r0,[r5,#0]
00005a  2020              MOVS     r0,#0x20
00005c  8020              STRH     r0,[r4,#0]
00005e  2100              MOVS     r1,#0
000060  8021              STRH     r1,[r4,#0]
;;;264    
;;;265        //step 3 : 设置PCLK，也就是像素时钟
;;;266        sLCD_WR_REG(0xE6);        //嗯，没错 0XE6是设置像素时钟的寄存器  
;;;267        sLCD_WR_Data(0x0001);//(0x01);//       //我的屏幕是4.3寸，这个频率就可以了，如果屏幕比较大，有闪烁的话，可以再加大
;;;268        sLCD_WR_Data(0x0093);//(0x93);//
;;;269        sLCD_WR_Data(0x0032);// ( 0xE0);//     //忘记说了，寄存器指令都是8位传输的，这里的像素时钟需要3个字节来设置，高位在前
;;;270    
;;;271        //step 4 : 设置LCD的显示模式，需要根据屏幕大小和LCD的电路控制方法相匹配，
;;;272        sLCD_WR_REG(0x00B0);        //设置LCD显示模式及分辨率
;;;273        sLCD_WR_Data(0x0020);//(0x0018);        // 使能FRC 0X0018 18bit LCD控制 
;;;274        sLCD_WR_Data(0x0000);     //TFT模式
;;;275        sLCD_WR_Data((HDP>>8)&0X00FF);  //Set HDP         水平大小
000062  4827              LDR      r0,|L10.256|
000064  6842              LDR      r2,[r0,#4]  ; HDP
000066  f3c22207          UBFX     r2,r2,#8,#8
00006a  8022              STRH     r2,[r4,#0]
;;;276        sLCD_WR_Data(HDP&0X00FF);             //双字节，高位在前
00006c  6842              LDR      r2,[r0,#4]  ; HDP
00006e  b2d2              UXTB     r2,r2
000070  8022              STRH     r2,[r4,#0]
;;;277        sLCD_WR_Data((VDP>>8)&0X00FF);  //Set VDP         垂直尺寸
000072  6942              LDR      r2,[r0,#0x14]  ; VDP
000074  f3c22207          UBFX     r2,r2,#8,#8
000078  8022              STRH     r2,[r4,#0]
;;;278        sLCD_WR_Data(VDP&0X00FF);
00007a  6942              LDR      r2,[r0,#0x14]  ; VDP
00007c  b2d2              UXTB     r2,r2
00007e  8022              STRH     r2,[r4,#0]
000080  8021              STRH     r1,[r4,#0]
000082  22b4              MOVS     r2,#0xb4
000084  802a              STRH     r2,[r5,#0]
;;;279        sLCD_WR_Data(0x0000);                        //RGB顺序串行TFT接口
;;;280    
;;;281        sLCD_WR_REG(0x00B4);        //设置  水平显示时间参数
;;;282        sLCD_WR_Data((HT>>8)&0X00FF);  //Set HT 水平总周期
000086  6882              LDR      r2,[r0,#8]  ; HT
000088  f3c22207          UBFX     r2,r2,#8,#8
00008c  8022              STRH     r2,[r4,#0]
;;;283        sLCD_WR_Data(HT&0X00FF);
00008e  6882              LDR      r2,[r0,#8]  ; HT
000090  b2d2              UXTB     r2,r2
000092  8022              STRH     r2,[r4,#0]
;;;284        sLCD_WR_Data((HPS>>8)&0X00FF);  //Set HPS 水平同步脉冲开始位
000094  68c2              LDR      r2,[r0,#0xc]  ; HPS
000096  f3c22207          UBFX     r2,r2,#8,#8
00009a  8022              STRH     r2,[r4,#0]
;;;285        sLCD_WR_Data(HPS&0X00FF);
00009c  68c2              LDR      r2,[r0,#0xc]  ; HPS
00009e  b2d2              UXTB     r2,r2
0000a0  8022              STRH     r2,[r4,#0]
;;;286        sLCD_WR_Data(HPW);                           //Set HPW 水平同步脉冲宽度
0000a2  7802              LDRB     r2,[r0,#0]  ; HPW
0000a4  8022              STRH     r2,[r4,#0]
;;;287        sLCD_WR_Data((LPS>>8)&0X00FF);  //Set LPS 显示开始位
0000a6  6902              LDR      r2,[r0,#0x10]  ; LPS
0000a8  f3c22207          UBFX     r2,r2,#8,#8
0000ac  8022              STRH     r2,[r4,#0]
;;;288        sLCD_WR_Data(LPS&0X00FF);
0000ae  6902              LDR      r2,[r0,#0x10]  ; LPS
0000b0  b2d2              UXTB     r2,r2
0000b2  8022              STRH     r2,[r4,#0]
0000b4  8021              STRH     r1,[r4,#0]
0000b6  22b6              MOVS     r2,#0xb6
0000b8  802a              STRH     r2,[r5,#0]
;;;289        sLCD_WR_Data(0x0000);         //TFT mode下，如此设置
;;;290    
;;;291        sLCD_WR_REG(0x00B6);        //设置        垂直显示时间参数
;;;292        sLCD_WR_Data((VT>>8)&0X00FF);   //Set VT 垂直总周期
0000ba  6982              LDR      r2,[r0,#0x18]  ; VT
0000bc  f3c22207          UBFX     r2,r2,#8,#8
0000c0  8022              STRH     r2,[r4,#0]
;;;293        sLCD_WR_Data(VT&0X00FF);
0000c2  6982              LDR      r2,[r0,#0x18]  ; VT
0000c4  b2d2              UXTB     r2,r2
0000c6  8022              STRH     r2,[r4,#0]
;;;294        sLCD_WR_Data((VPS>>8)&0X00FF);  //Set VPS 垂直同步脉冲开始位
0000c8  69c2              LDR      r2,[r0,#0x1c]  ; VPS
0000ca  f3c22207          UBFX     r2,r2,#8,#8
0000ce  8022              STRH     r2,[r4,#0]
;;;295        sLCD_WR_Data(VPS&0X00FF);
0000d0  69c2              LDR      r2,[r0,#0x1c]  ; VPS
0000d2  b2d2              UXTB     r2,r2
0000d4  8022              STRH     r2,[r4,#0]
;;;296        sLCD_WR_Data(VPW);                           //Set VPW垂直同步脉冲宽度
0000d6  7842              LDRB     r2,[r0,#1]  ; VPW
0000d8  8022              STRH     r2,[r4,#0]
;;;297        sLCD_WR_Data((FPS>>8)&0X00FF);  //Set FPS  显示开始位置
0000da  6a02              LDR      r2,[r0,#0x20]  ; FPS
0000dc  f3c22207          UBFX     r2,r2,#8,#8
0000e0  8022              STRH     r2,[r4,#0]
;;;298        sLCD_WR_Data(FPS&0X00FF);
0000e2  6a00              LDR      r0,[r0,#0x20]  ; FPS
0000e4  b2c0              UXTB     r0,r0
0000e6  8020              STRH     r0,[r4,#0]
0000e8  2036              MOVS     r0,#0x36
0000ea  8028              STRH     r0,[r5,#0]
0000ec  8021              STRH     r1,[r4,#0]
0000ee  20f0              MOVS     r0,#0xf0
0000f0  8028              STRH     r0,[r5,#0]
0000f2  8026              STRH     r6,[r4,#0]
0000f4  2029              MOVS     r0,#0x29
0000f6  8028              STRH     r0,[r5,#0]
;;;299        
;;;300        sLCD_WR_REG(0X0036);    //设置从主机读取指令顺序，可以省略，上电默认为0
;;;301        sLCD_WR_Data(0X0000);
;;;302        sLCD_WR_REG(0x00F0); //pixel data interface  设置像素数据接口为16位
;;;303        sLCD_WR_Data(0x0003); //03为 565 的16位通讯。
;;;304        
;;;305        //step 5 : 可选。设置图形后处理。
;;;306        //sLCD_WR_REG(0x0021);        //进入图形颜色翻转模式 
;;;307    
;;;308        //sLCD_WR_REG(0x00BC);//设置图像后处理
;;;309        //sLCD_WR_Data(0x005A);//(0x0080);//对比度
;;;310        //sLCD_WR_Data(0x0064);//(0x0080);//亮度
;;;311        //sLCD_WR_Data(0x005A);//(0x0080);//饱和度值  //
;;;312        //sLCD_WR_Data(0x0001);//处理机允许
;;;313    
;;;314        //sLCD_Clear(0Xffff);//刷成白色
;;;315        //sLCD_Clear(0x0000000);//黑色
;;;316        sLCD_WR_REG(0x0029); //display on
;;;317        
;;;318    //    // step 6 ，背光设置，也是屏幕亮起来的一步。
;;;319    //    sLCD_WR_REG(0x00BE); //set PWM控制
;;;320    //    sLCD_WR_Data(0x0006);        //PWM频率 = PLL / (256* 0x06) /256        
;;;321    //    sLCD_WR_Data(0x00ff); // PWM占空比设置 
;;;322    //    sLCD_WR_Data(0x09); //DBC 控制PWM 使能 
;;;323    //    sLCD_WR_Data(0xFF); //DBC手动亮度设置
;;;324    //    sLCD_WR_Data(0x00); //DBC 最小亮度设置 
;;;325    //    sLCD_WR_Data(0x00);
;;;326    //
;;;327    //    sLCD_WR_REG(0xD4); //设置每个等级的电源阀值
;;;328    //    //TH1 = display width * display height * 3 * 0.1 /16 
;;;329    //    //480*272 * 3 * 0.1 /16 =990H
;;;330    //    sLCD_WR_Data(0x00); // 
;;;331    //    sLCD_WR_Data(0x09); // 
;;;332    //    sLCD_WR_Data(0x90); // 
;;;333    //  
;;;334    //    //TH2 = display width * display height * 3 * 0.25 /16
;;;335    //    //480*272 * 3 * 0.25 /16 =17E8H
;;;336    //    sLCD_WR_Data(0x00); // 
;;;337    //    sLCD_WR_Data(0xE8); // 
;;;338    //
;;;339    //    //TH3 = display width * display height * 3 * 0.6 /16 
;;;340    //    //480*272 * 3 * 0.6 /16 =3960H
;;;341    //    sLCD_WR_Data(0x00); // 
;;;342    //    sLCD_WR_Data(0x39); // 
;;;343    //    sLCD_WR_Data(0x60); //
;;;344    //                 
;;;345    //    sLCD_WR_REG(0x00d0);//设置动态背光控制配置 
;;;346    //    sLCD_WR_Data(0x000d); 
;;;347    }
0000f8  bdf0              POP      {r4-r7,pc}
;;;348    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L10.252|
                          DCD      0x60020000
                  |L10.256|
                          DCD      ||.data||

                          AREA ||i.sLCD_OpenWindow||, CODE, READONLY, ALIGN=2

                  sLCD_OpenWindow PROC
;;;50     
;;;51     void sLCD_OpenWindow(vu32 x1, vu32 y1, vu32 x2, vu32 y2)
000000  b530              PUSH     {r4,r5,lr}
000002  f04f45c0          MOV      r5,#0x60000000
000006  242a              MOVS     r4,#0x2a
000008  802c              STRH     r4,[r5,#0]
00000a  4c0a              LDR      r4,|L11.52|
;;;52     {
;;;53     	sLCD_WR_REG(0x002a);
;;;54     	sLCD_WR_Data(x1>>8);
00000c  ea4f2c10          LSR      r12,r0,#8
000010  f8a4c000          STRH     r12,[r4,#0]
000014  8020              STRH     r0,[r4,#0]
;;;55     	sLCD_WR_Data(x1);
;;;56     	sLCD_WR_Data(x2>>8);
000016  0a10              LSRS     r0,r2,#8
000018  8020              STRH     r0,[r4,#0]
00001a  8022              STRH     r2,[r4,#0]
00001c  202b              MOVS     r0,#0x2b
00001e  8028              STRH     r0,[r5,#0]
;;;57     	sLCD_WR_Data(x2);
;;;58     
;;;59     	sLCD_WR_REG(0x002b);
;;;60     	sLCD_WR_Data(y1>>8);
000020  0a08              LSRS     r0,r1,#8
000022  8020              STRH     r0,[r4,#0]
000024  8021              STRH     r1,[r4,#0]
;;;61     	sLCD_WR_Data(y1);
;;;62     	sLCD_WR_Data(y2>>8);
000026  0a18              LSRS     r0,r3,#8
000028  8020              STRH     r0,[r4,#0]
00002a  8023              STRH     r3,[r4,#0]
00002c  202c              MOVS     r0,#0x2c
00002e  8028              STRH     r0,[r5,#0]
;;;63     	sLCD_WR_Data(y2);
;;;64     	sLCD_WR_REG(0x002C);
;;;65     }
000030  bd30              POP      {r4,r5,pc}
;;;66     
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x60020000

                          AREA ||i.sLCD_Read_Data||, CODE, READONLY, ALIGN=2

                  sLCD_Read_Data PROC
;;;41     
;;;42     vu16 sLCD_Read_Data(void)
000000  4801              LDR      r0,|L12.8|
;;;43     {
;;;44      
;;;45     
;;;46        return  *(__IO u16 *) (Bank1_LCD_D);
000002  8800              LDRH     r0,[r0,#0]
;;;47     
;;;48          
;;;49     }
000004  4770              BX       lr
;;;50     
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x60020000

                          AREA ||i.sLCD_WR_Data||, CODE, READONLY, ALIGN=2

                  sLCD_WR_Data PROC
;;;36     
;;;37     void sLCD_WR_Data(unsigned int val)
000000  4901              LDR      r1,|L13.8|
;;;38     {   
;;;39     	*(__IO u16 *) (Bank1_LCD_D)= val; 	
000002  8008              STRH     r0,[r1,#0]
;;;40     }
000004  4770              BX       lr
;;;41     
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x60020000

                          AREA ||i.sLCD_WR_REG||, CODE, READONLY, ALIGN=1

                  sLCD_WR_REG PROC
;;;30     
;;;31     void sLCD_WR_REG(unsigned int index)
000000  f04f41c0          MOV      r1,#0x60000000
;;;32     {
;;;33     	*(__IO u16 *) (Bank1_LCD_C)= index;
000004  8008              STRH     r0,[r1,#0]
;;;34     
;;;35     }
000006  4770              BX       lr
;;;36     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  HPW
000000  0a                DCB      0x0a
                  VPW
000001  0a0000            DCB      0x0a,0x00,0x00
                  HDP
                          DCD      0x000001df
                  ||HT||
                          DCD      0x00000213
                  HPS
                          DCD      0x0000002b
                  LPS
                          DCD      0x00000008
                  VDP
                          DCD      0x0000010f
                  ||VT||
                          DCD      0x00000120
                  VPS
                          DCD      0x0000000c
                  ||FPS||
                          DCD      0x00000004

;*** Start embedded assembler ***

#line 1 "..\\drive\\ssd1963.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_ssd1963_c_HDP____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_ssd1963_c_HDP____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_ssd1963_c_HDP____REVSH|
#line 128
|__asm___9_ssd1963_c_HDP____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
