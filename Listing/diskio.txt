; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\diskio.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\FATFS -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\diskio.crf --no_multibyte_chars ..\FATFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;42     //初始化磁盘
;;;43     DSTATUS disk_initialize (
000000  b510              PUSH     {r4,lr}
;;;44     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;45     )
;;;46     {
;;;47     	u8 res=0;	    
;;;48     	switch(pdrv)
000002  2802              CMP      r0,#2
000004  d001              BEQ      |L1.10|
;;;49     	{
;;;50     //		case SD_CARD://SD卡
;;;51     //			res=SD_Init();//SD卡初始化 
;;;52     //  			break;
;;;53     //		case EX_FLASH://外部flash
;;;54     //			W25QXX_Init();
;;;55     //			FLASH_SECTOR_COUNT=2048*12;//W25Q1218,前12M字节给FATFS占用 
;;;56     // 			break;
;;;57     		case USB_DISK://外部flash
;;;58     	  		if(USBH_UDISK_Status())return 0;	//U盘连接成功,则返回1.否则返回0		  
;;;59     			else return 1;	 
;;;60     		default:
;;;61     			res=1; 
;;;62     	}		 
;;;63     	if(res)return  STA_NOINIT;
000006  2001              MOVS     r0,#1
;;;64     	else return 0; //初始化成功
;;;65     }  
000008  bd10              POP      {r4,pc}
                  |L1.10|
00000a  f7fffffe          BL       USBH_UDISK_Status
00000e  b108              CBZ      r0,|L1.20|
000010  2000              MOVS     r0,#0                 ;58
000012  bd10              POP      {r4,pc}
                  |L1.20|
000014  2001              MOVS     r0,#1                 ;59
000016  bd10              POP      {r4,pc}
;;;66     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;172    #if _USE_IOCTL
;;;173    DRESULT disk_ioctl (
000000  4603              MOV      r3,r0
;;;174    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;175    	BYTE cmd,		/* Control code */
;;;176    	void *buff		/* Buffer to send/receive control data */
;;;177    )
;;;178    {
;;;179    	DRESULT res;						  			     
;;;180    	if(pdrv==SD_CARD)//SD卡
000002  2b00              CMP      r3,#0
000004  d006              BEQ      |L2.20|
;;;181    	{
;;;182    //	    switch(cmd)
;;;183    //	    {
;;;184    //		    case CTRL_SYNC:
;;;185    //				res = RES_OK; 
;;;186    //		        break;	 
;;;187    //		    case GET_SECTOR_SIZE:
;;;188    //				*(DWORD*)buff = 512; 
;;;189    //		        res = RES_OK;
;;;190    //		        break;	 
;;;191    //		    case GET_BLOCK_SIZE:
;;;192    //				*(WORD*)buff = SDCardInfo.CardBlockSize;
;;;193    //		        res = RES_OK;
;;;194    //		        break;	 
;;;195    //		    case GET_SECTOR_COUNT:
;;;196    //		        *(DWORD*)buff = SDCardInfo.CardCapacity/512;
;;;197    //		        res = RES_OK;
;;;198    //		        break;
;;;199    //		    default:
;;;200    //		        res = RES_PARERR;
;;;201    //		        break;
;;;202    //	    }
;;;203    	}else if(pdrv==EX_FLASH)	//外部FLASH  
;;;204    	{
;;;205    	    switch(cmd)
;;;206    	    {
;;;207    		    case CTRL_SYNC:
;;;208    				res = RES_OK; 
;;;209    		        break;	 
;;;210    		    case GET_SECTOR_SIZE:
;;;211    		        *(WORD*)buff = FLASH_SECTOR_SIZE;
000006  f44f7000          MOV      r0,#0x200
00000a  2b01              CMP      r3,#1                 ;203
00000c  d003              BEQ      |L2.22|
;;;212    		        res = RES_OK;
;;;213    		        break;	 
;;;214    		    case GET_BLOCK_SIZE:
;;;215    		        *(WORD*)buff = FLASH_BLOCK_SIZE;
;;;216    		        res = RES_OK;
;;;217    		        break;	 
;;;218    		    case GET_SECTOR_COUNT:
;;;219    		        *(DWORD*)buff = FLASH_SECTOR_COUNT;
;;;220    		        res = RES_OK;
;;;221    		        break;
;;;222    		    default:
;;;223    		        res = RES_PARERR;
;;;224    		        break;
;;;225    	    }
;;;226    	}else if(pdrv==USB_DISK)	//U盘
00000e  2b02              CMP      r3,#2
000010  d018              BEQ      |L2.68|
;;;227    	{
;;;228    	    switch(cmd)
;;;229    	    {
;;;230    		    case CTRL_SYNC:
;;;231    				res = RES_OK; 
;;;232    		        break;	 
;;;233    		    case GET_SECTOR_SIZE:
;;;234    		        *(WORD*)buff=512;
;;;235    		        res = RES_OK;
;;;236    		        break;	 
;;;237    		    case GET_BLOCK_SIZE:
;;;238    		        *(WORD*)buff=512;
;;;239    		        res = RES_OK;
;;;240    		        break;	 
;;;241    		    case GET_SECTOR_COUNT:
;;;242    		        *(DWORD*)buff=USBH_MSC_Param.MSCapacity;
;;;243    		        res = RES_OK;
;;;244    		        break;
;;;245    		    default:
;;;246    		        res = RES_PARERR;
;;;247    		        break;
;;;248    	    }		
;;;249    	}else res=RES_ERROR;//其他的不支持
000012  2001              MOVS     r0,#1
                  |L2.20|
;;;250        return res;
;;;251    }
000014  4770              BX       lr
                  |L2.22|
000016  b139              CBZ      r1,|L2.40|
000018  2901              CMP      r1,#1                 ;205
00001a  d00e              BEQ      |L2.58|
00001c  2902              CMP      r1,#2                 ;205
00001e  d005              BEQ      |L2.44|
000020  2903              CMP      r1,#3                 ;205
000022  d006              BEQ      |L2.50|
000024  2004              MOVS     r0,#4                 ;223
000026  4770              BX       lr
                  |L2.40|
000028  2000              MOVS     r0,#0                 ;208
00002a  4770              BX       lr
                  |L2.44|
00002c  8010              STRH     r0,[r2,#0]            ;211
00002e  2000              MOVS     r0,#0                 ;212
000030  4770              BX       lr
                  |L2.50|
000032  2008              MOVS     r0,#8                 ;215
000034  8010              STRH     r0,[r2,#0]            ;215
000036  2000              MOVS     r0,#0                 ;216
000038  4770              BX       lr
                  |L2.58|
00003a  480d              LDR      r0,|L2.112|
00003c  8800              LDRH     r0,[r0,#0]            ;219  ; FLASH_SECTOR_COUNT
00003e  6010              STR      r0,[r2,#0]            ;219
000040  2000              MOVS     r0,#0                 ;220
000042  4770              BX       lr
                  |L2.68|
000044  b139              CBZ      r1,|L2.86|
000046  2901              CMP      r1,#1                 ;228
000048  d00d              BEQ      |L2.102|
00004a  2902              CMP      r1,#2                 ;228
00004c  d005              BEQ      |L2.90|
00004e  2903              CMP      r1,#3                 ;228
000050  d006              BEQ      |L2.96|
000052  2004              MOVS     r0,#4                 ;246
000054  4770              BX       lr
                  |L2.86|
000056  2000              MOVS     r0,#0                 ;231
000058  4770              BX       lr
                  |L2.90|
00005a  8010              STRH     r0,[r2,#0]            ;234
00005c  2000              MOVS     r0,#0                 ;235
00005e  4770              BX       lr
                  |L2.96|
000060  8010              STRH     r0,[r2,#0]            ;238
000062  2000              MOVS     r0,#0                 ;239
000064  4770              BX       lr
                  |L2.102|
000066  4803              LDR      r0,|L2.116|
000068  6800              LDR      r0,[r0,#0]            ;242  ; USBH_MSC_Param
00006a  6010              STR      r0,[r2,#0]            ;242
00006c  2000              MOVS     r0,#0                 ;243
00006e  4770              BX       lr
;;;252    #endif
                          ENDP

                  |L2.112|
                          DCD      ||.data||
                  |L2.116|
                          DCD      USBH_MSC_Param

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;79     //count:需要读取的扇区数
;;;80     DRESULT disk_read (
000000  b510              PUSH     {r4,lr}
;;;81     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;82     	BYTE *buff,		/* Data buffer to store read data */
;;;83     	DWORD sector,	/* Sector address (LBA) */
;;;84     	UINT count		/* Number of sectors to read (1..128) */
;;;85     )
;;;86     {
000002  460c              MOV      r4,r1
000004  4611              MOV      r1,r2
000006  461a              MOV      r2,r3
;;;87     	u8 res=0; 
;;;88         if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000008  2a00              CMP      r2,#0
00000a  d005              BEQ      |L3.24|
;;;89     	switch(pdrv)
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L3.28|
;;;90     	{
;;;91     //		case SD_CARD://SD卡
;;;92     //			res=SD_ReadDisk(buff,sector,count);	 
;;;93     //			while(res)//读出错
;;;94     //			{
;;;95     //				SD_Init();	//重新初始化SD卡
;;;96     //				res=SD_ReadDisk(buff,sector,count);	
;;;97     //				//printf("sd rd error:%d\r\n",res);
;;;98     //			}
;;;99     //			break;
;;;100    //		case EX_FLASH://外部flash
;;;101    //			for(;count>0;count--)
;;;102    //			{
;;;103    //				W25QXX_Read(buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;104    //				sector++;
;;;105    //				buff+=FLASH_SECTOR_SIZE;
;;;106    //			}
;;;107    //			res=0;
;;;108    //			break;
;;;109    		case USB_DISK://U盘 
;;;110    			res=USBH_UDISK_Read(buff,sector,count);	  
;;;111    			break;
;;;112    		default:
;;;113    			res=1; 
000010  2001              MOVS     r0,#1
                  |L3.18|
;;;114    	}
;;;115       //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;116        if(res==0x00)return RES_OK;	 
000012  b138              CBZ      r0,|L3.36|
;;;117        else return RES_ERROR;	   
000014  2001              MOVS     r0,#1
;;;118    }
000016  bd10              POP      {r4,pc}
                  |L3.24|
000018  2004              MOVS     r0,#4                 ;88
00001a  bd10              POP      {r4,pc}
                  |L3.28|
00001c  4620              MOV      r0,r4                 ;110
00001e  f7fffffe          BL       USBH_UDISK_Read
000022  e7f6              B        |L3.18|
                  |L3.36|
000024  2000              MOVS     r0,#0                 ;116
000026  bd10              POP      {r4,pc}
;;;119    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;67     //获得磁盘状态
;;;68     DSTATUS disk_status (
000000  2000              MOVS     r0,#0
;;;69     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;70     )
;;;71     { 
;;;72     	return 0;
;;;73     } 
000002  4770              BX       lr
;;;74     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;125    #if _USE_WRITE
;;;126    DRESULT disk_write (
000000  b510              PUSH     {r4,lr}
;;;127    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;128    	const BYTE *buff,	/* Data to be written */
;;;129    	DWORD sector,		/* Sector address (LBA) */
;;;130    	UINT count			/* Number of sectors to write (1..128) */
;;;131    )
;;;132    {
000002  460c              MOV      r4,r1
000004  4611              MOV      r1,r2
000006  461a              MOV      r2,r3
;;;133    	u8 res=0;  
;;;134        if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000008  2a00              CMP      r2,#0
00000a  d005              BEQ      |L5.24|
;;;135    	switch(pdrv)
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L5.28|
;;;136    	{
;;;137    //		case SD_CARD://SD卡
;;;138    //			res=SD_WriteDisk((u8*)buff,sector,count);
;;;139    //			while(res)//写出错
;;;140    //			{
;;;141    //				SD_Init();	//重新初始化SD卡
;;;142    //				res=SD_WriteDisk((u8*)buff,sector,count);	
;;;143    //				//printf("sd wr error:%d\r\n",res);
;;;144    //			}
;;;145    //			break;
;;;146    //		case EX_FLASH://外部flash
;;;147    //			for(;count>0;count--)
;;;148    //			{										    
;;;149    //				W25QXX_Write((u8*)buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;150    //				sector++;
;;;151    //				buff+=FLASH_SECTOR_SIZE;
;;;152    //			}
;;;153    //			res=0;
;;;154    //			break;
;;;155    		case USB_DISK://U盘
;;;156    			res=USBH_UDISK_Write((u8*)buff,sector,count); 
;;;157    			break;
;;;158    		default:
;;;159    			res=1; 
000010  2001              MOVS     r0,#1
                  |L5.18|
;;;160    	}
;;;161        //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;162        if(res == 0x00)return RES_OK;	 
000012  b138              CBZ      r0,|L5.36|
;;;163        else return RES_ERROR;	
000014  2001              MOVS     r0,#1
;;;164    }
000016  bd10              POP      {r4,pc}
                  |L5.24|
000018  2004              MOVS     r0,#4                 ;134
00001a  bd10              POP      {r4,pc}
                  |L5.28|
00001c  4620              MOV      r0,r4                 ;156
00001e  f7fffffe          BL       USBH_UDISK_Write
000022  e7f6              B        |L5.18|
                  |L5.36|
000024  2000              MOVS     r0,#0                 ;162
000026  bd10              POP      {r4,pc}
;;;165    #endif
                          ENDP


                          AREA ||i.ff_memalloc||, CODE, READONLY, ALIGN=1

                  ff_memalloc PROC
;;;261    //动态分配内存
;;;262    void *ff_memalloc (UINT size)			
000000  4601              MOV      r1,r0
;;;263    {
;;;264    	return (void*)mymalloc(SRAMIN,size);
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      mymalloc
;;;265    }
;;;266    //释放内存
                          ENDP


                          AREA ||i.ff_memfree||, CODE, READONLY, ALIGN=1

                  ff_memfree PROC
;;;266    //释放内存
;;;267    void ff_memfree (void* mf)		 
000000  4601              MOV      r1,r0
;;;268    {
;;;269    	myfree(SRAMIN,mf);
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      myfree
;;;270    }
;;;271    
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;256    //15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */                                                                                                                                                                                                                                                
;;;257    DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;258    {				 
;;;259    	return 0;
;;;260    }			 
000002  4770              BX       lr
;;;261    //动态分配内存
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  FLASH_SECTOR_COUNT
000000  6000              DCW      0x6000

;*** Start embedded assembler ***

#line 1 "..\\FATFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_e3159e14____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REVSH|
#line 144
|__asm___8_diskio_c_e3159e14____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
