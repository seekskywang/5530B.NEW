; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\ad7689.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\ad7689.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\FATFS -I..\IAP -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\ad7689.crf --no_multibyte_chars ..\drive\AD7689.c]
                          THUMB

                          AREA ||i.AD7689_Delay||, CODE, READONLY, ALIGN=1

                  AD7689_Delay PROC
;;;421    /************************************************************************/
;;;422    void AD7689_Delay(void)
000000  b508              PUSH     {r3,lr}
;;;423    {
;;;424    	vu16 count ;
;;;425      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
000006  9000              STR      r0,[sp,#0]
000008  e003              B        |L1.18|
                  |L1.10|
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  9000              STR      r0,[sp,#0]
                  |L1.18|
000012  f8bd0000          LDRH     r0,[sp,#0]
000016  2800              CMP      r0,#0
000018  d1f7              BNE      |L1.10|
;;;426    }
00001a  bd08              POP      {r3,pc}
;;;427    void AD7689_Delay1(void)
                          ENDP


                          AREA ||i.AD7689_Delay1||, CODE, READONLY, ALIGN=1

                  AD7689_Delay1 PROC
;;;426    }
;;;427    void AD7689_Delay1(void)
000000  b508              PUSH     {r3,lr}
;;;428    {
;;;429    	vu16 count ;
;;;430      for(count = 3000; count != 0; count--);
000002  f64030b8          MOV      r0,#0xbb8
000006  9000              STR      r0,[sp,#0]
000008  e003              B        |L2.18|
                  |L2.10|
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  9000              STR      r0,[sp,#0]
                  |L2.18|
000012  f8bd0000          LDRH     r0,[sp,#0]
000016  2800              CMP      r0,#0
000018  d1f7              BNE      |L2.10|
;;;431    }
00001a  bd08              POP      {r3,pc}
;;;432    void AD7689_Scan_CH(void)
                          ENDP


                          AREA ||i.AD7689_InitializeSPI2||, CODE, READONLY, ALIGN=2

                  AD7689_InitializeSPI2 PROC
;;;280    void Bubble_sort(vu16 *D_temp,vu8 num);
;;;281    void AD7689_InitializeSPI2(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;282    {
;;;283    	GPIO_InitTypeDef  GPIO_InitStructure;
;;;284      //SPI_InitTypeDef  SPI_InitStructure;
;;;285      /*!< SD_SPI_CS_GPIO, SD_SPI_MOSI_GPIO, SD_SPI_MISO_GPIO, SD_SPI_DETECT_GPIO 
;;;286           and SD_SPI_SCK_GPIO Periph clock enable 
;;;287    	// 	 RCC_AHBPeriphClockCmd(FLASH_CS_PIN_SCK|FLASH_SCK_PIN_SCK|FLASH_MISO_PIN_SCK | FLASH_MOSI_PIN_SCK, ENABLE);
;;;288      !< SD_SPI Periph clock enable */
;;;289    	/*RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
;;;290    	
;;;291    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
;;;292    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;293    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;294    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//inv
;;;295    	GPIO_Init(GPIOA, &GPIO_InitStructure);//
;;;296      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3;//PC2~3复用功能输出	
;;;297      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
;;;298      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
;;;299      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
;;;300      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
;;;301      GPIO_Init(GPIOC, &GPIO_InitStructure);//初始化
;;;302    	
;;;303    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PB10复用功能输出	
;;;304      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
;;;305      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
;;;306      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
;;;307      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
;;;308      GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
;;;309    	
;;;310      GPIO_PinAFConfig(GPIOC,GPIO_PinSource2,GPIO_AF_SPI2); //PC2复用为 SPI2
;;;311    	GPIO_PinAFConfig(GPIOC,GPIO_PinSource3,GPIO_AF_SPI2); //PBC3复用为 SPI2
;;;312    	GPIO_PinAFConfig(GPIOB,GPIO_PinSource10,GPIO_AF_SPI2); //PB13复用为 SPI2
;;;313    	AD7689_CNV_1;
;;;314    	AD7689_Delay();
;;;315    	AD7689_CNV_0;
;;;316    	//这里只针对SPI口初始化
;;;317      SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
;;;318    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
;;;319    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;		//设置SPI的数据大小:SPI发送接收16位帧结构
;;;320    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为高电平
;;;321    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
;;;322    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
;;;323    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
;;;324    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
;;;325    	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
;;;326    	SPI_Init(SPI2, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
;;;327    	
;;;328    	SPI_Cmd(SPI2, ENABLE);*/ //使能SPI外设*/
;;;329    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
000004  2602              MOVS     r6,#2
000006  f88d6005          STRB     r6,[sp,#5]
;;;330    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
00000a  2401              MOVS     r4,#1
00000c  f88d4004          STRB     r4,[sp,#4]
;;;331    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000010  2500              MOVS     r5,#0
000012  f88d5006          STRB     r5,[sp,#6]
;;;332    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;//inv
000016  2040              MOVS     r0,#0x40
000018  9000              STR      r0,[sp,#0]
;;;333    	GPIO_Init(GPIOB, &GPIO_InitStructure);//
00001a  4f1a              LDR      r7,|L3.132|
00001c  4669              MOV      r1,sp
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       GPIO_Init
;;;334    
;;;335    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
000024  f88d6005          STRB     r6,[sp,#5]
;;;336    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000028  f88d4004          STRB     r4,[sp,#4]
;;;337    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00002c  f88d5006          STRB     r5,[sp,#6]
;;;338    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//sck,
000030  2008              MOVS     r0,#8
000032  9000              STR      r0,[sp,#0]
;;;339    	GPIO_Init(GPIOB, &GPIO_InitStructure);//
000034  4669              MOV      r1,sp
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       GPIO_Init
;;;340    	
;;;341    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00003c  f88d6005          STRB     r6,[sp,#5]
;;;342    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000040  f88d4004          STRB     r4,[sp,#4]
;;;343    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000044  f88d5006          STRB     r5,[sp,#6]
;;;344    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;//MOSI
000048  2020              MOVS     r0,#0x20
00004a  9000              STR      r0,[sp,#0]
;;;345    	GPIO_Init(GPIOB, &GPIO_InitStructure);//
00004c  4669              MOV      r1,sp
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       GPIO_Init
;;;346    	
;;;347    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;;
000054  f88d5004          STRB     r5,[sp,#4]
;;;348    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;;
000058  f88d4007          STRB     r4,[sp,#7]
;;;349    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;//MISO
00005c  2010              MOVS     r0,#0x10
00005e  9000              STR      r0,[sp,#0]
;;;350    	GPIO_Init(GPIOB, &GPIO_InitStructure);//
000060  4669              MOV      r1,sp
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       GPIO_Init
;;;351    	
;;;352    	AD7689_CNV_1;
000068  2140              MOVS     r1,#0x40
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       GPIO_SetBits
;;;353    	GPIO_SetBits(GPIOB,GPIO_Pin_5);//MOSI=0
000070  2120              MOVS     r1,#0x20
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       GPIO_SetBits
;;;354    	GPIO_SetBits(GPIOB,GPIO_Pin_3);//SCK=0
000078  2108              MOVS     r1,#8
00007a  4638              MOV      r0,r7
00007c  f7fffffe          BL       GPIO_SetBits
;;;355    }
000080  e8bd81fc          POP      {r2-r8,pc}
;;;356    
                          ENDP

                  |L3.132|
                          DCD      0x40020400

                          AREA ||i.AD7689_Scan_CH||, CODE, READONLY, ALIGN=2

                  AD7689_Scan_CH PROC
;;;431    }
;;;432    void AD7689_Scan_CH(void)
000000  b570              PUSH     {r4-r6,lr}
;;;433    {
000002  b086              SUB      sp,sp,#0x18
;;;434    	static vu8 I_cont,I1_cont,V_cont;
;;;435    	vu8 i,f;
;;;436    	vu32 sum1;
;;;437    	vu16 var_chI,var_chV,var_chV1;
;;;438    	for(i=0;i<8;i++)
000004  2500              MOVS     r5,#0
000006  9505              STR      r5,[sp,#0x14]
;;;439    		{
;;;440    			AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
000008  4c48              LDR      r4,|L4.300|
00000a  e014              B        |L4.54|
                  |L4.12|
00000c  f89d1014          LDRB     r1,[sp,#0x14]
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       SPI_AD7689_Read
000016  f89d1014          LDRB     r1,[sp,#0x14]
00001a  f8240011          STRH     r0,[r4,r1,LSL #1]
;;;441    			AD7689_Delay1();
00001e  f7fffffe          BL       AD7689_Delay1
;;;442    			var_chI=AD7689_Buffer[3];
000022  88e0              LDRH     r0,[r4,#6]  ; AD7689_Buffer
000024  9002              STR      r0,[sp,#8]
;;;443    			var_chV=AD7689_Buffer[2];
000026  88a0              LDRH     r0,[r4,#4]  ; AD7689_Buffer
000028  9001              STR      r0,[sp,#4]
;;;444    			var_chV1=AD7689_Buffer[4];
00002a  8920              LDRH     r0,[r4,#8]  ; AD7689_Buffer
00002c  9000              STR      r0,[sp,#0]
00002e  f89d0014          LDRB     r0,[sp,#0x14]         ;438
000032  1c40              ADDS     r0,r0,#1              ;438
000034  9005              STR      r0,[sp,#0x14]         ;438
                  |L4.54|
000036  f89d0014          LDRB     r0,[sp,#0x14]         ;438
00003a  2808              CMP      r0,#8                 ;438
00003c  d3e6              BCC      |L4.12|
;;;445    		}
;;;446    	/***************电源电流滤波**********************/
;;;447    	Ad7689_Fit_Imon1[I1_cont++]=var_chI;
00003e  f8bd2008          LDRH     r2,[sp,#8]
000042  4e3b              LDR      r6,|L4.304|
000044  7870              LDRB     r0,[r6,#1]  ; I1_cont
000046  1c41              ADDS     r1,r0,#1
000048  7071              STRB     r1,[r6,#1]
00004a  4c38              LDR      r4,|L4.300|
00004c  34d8              ADDS     r4,r4,#0xd8
00004e  f8242010          STRH     r2,[r4,r0,LSL #1]
;;;448    	if(I1_cont==20)
000052  7870              LDRB     r0,[r6,#1]  ; I1_cont
000054  2814              CMP      r0,#0x14
000056  d100              BNE      |L4.90|
;;;449    	{
;;;450    		I1_cont=0;
000058  7075              STRB     r5,[r6,#1]
                  |L4.90|
;;;451    	}
;;;452    	Bubble_sort( Ad7689_Fit_Imon1,20);//排序从大到小
00005a  4834              LDR      r0,|L4.300|
00005c  2114              MOVS     r1,#0x14
00005e  30d8              ADDS     r0,r0,#0xd8
000060  f7fffffe          BL       Bubble_sort
;;;453    	sum1=0;
000064  9503              STR      r5,[sp,#0xc]
;;;454    	for(f=2;f<16;f++)
000066  2202              MOVS     r2,#2
000068  9204              STR      r2,[sp,#0x10]
00006a  e00a              B        |L4.130|
                  |L4.108|
;;;455    	{
;;;456    		sum1 +=Ad7689_Fit_Imon1[f];
00006c  f89d0010          LDRB     r0,[sp,#0x10]
000070  f8340010          LDRH     r0,[r4,r0,LSL #1]
000074  9903              LDR      r1,[sp,#0xc]
000076  4408              ADD      r0,r0,r1
000078  9003              STR      r0,[sp,#0xc]
00007a  f89d0010          LDRB     r0,[sp,#0x10]         ;454
00007e  1c40              ADDS     r0,r0,#1              ;454
000080  9004              STR      r0,[sp,#0x10]         ;454
                  |L4.130|
000082  f89d0010          LDRB     r0,[sp,#0x10]         ;454
000086  2810              CMP      r0,#0x10              ;454
000088  d3f0              BCC      |L4.108|
;;;457    	}
;;;458    	Imon_value=sum1/14;
00008a  9803              LDR      r0,[sp,#0xc]
00008c  230e              MOVS     r3,#0xe
00008e  fbb0f0f3          UDIV     r0,r0,r3
000092  4928              LDR      r1,|L4.308|
000094  8008              STRH     r0,[r1,#0]
;;;459    	/***************负载电压滤波**********************/
;;;460    	Ad7689_Fit_Vmon[V_cont++]=var_chV;
000096  f8bd4004          LDRH     r4,[sp,#4]
00009a  78b0              LDRB     r0,[r6,#2]  ; V_cont
00009c  1c41              ADDS     r1,r0,#1
00009e  70b1              STRB     r1,[r6,#2]
0000a0  0041              LSLS     r1,r0,#1
0000a2  4825              LDR      r0,|L4.312|
0000a4  5244              STRH     r4,[r0,r1]
;;;461    	if(V_cont==20)
0000a6  78b1              LDRB     r1,[r6,#2]  ; V_cont
0000a8  2914              CMP      r1,#0x14
0000aa  d100              BNE      |L4.174|
;;;462    	{
;;;463    		V_cont=0;
0000ac  70b5              STRB     r5,[r6,#2]
                  |L4.174|
;;;464    	}
;;;465    //	Bubble_sort( Ad7689_Fit_Vmon,20);//排序从大到小
;;;466    	sum1=0;
0000ae  9503              STR      r5,[sp,#0xc]
;;;467    	for(f=2;f<16;f++)
0000b0  9204              STR      r2,[sp,#0x10]
0000b2  e00a              B        |L4.202|
                  |L4.180|
;;;468    	{
;;;469    		sum1 +=Ad7689_Fit_Vmon[f];
0000b4  f89d1010          LDRB     r1,[sp,#0x10]
0000b8  f8301011          LDRH     r1,[r0,r1,LSL #1]
0000bc  9a03              LDR      r2,[sp,#0xc]
0000be  4411              ADD      r1,r1,r2
0000c0  9103              STR      r1,[sp,#0xc]
0000c2  f89d1010          LDRB     r1,[sp,#0x10]         ;467
0000c6  1c49              ADDS     r1,r1,#1              ;467
0000c8  9104              STR      r1,[sp,#0x10]         ;467
                  |L4.202|
0000ca  f89d1010          LDRB     r1,[sp,#0x10]         ;467
0000ce  2910              CMP      r1,#0x10              ;467
0000d0  d3f0              BCC      |L4.180|
;;;470    	}
;;;471    	Vmon1_value=sum1/14;
0000d2  9803              LDR      r0,[sp,#0xc]
0000d4  4919              LDR      r1,|L4.316|
0000d6  fbb0f0f3          UDIV     r0,r0,r3
0000da  6008              STR      r0,[r1,#0]  ; Vmon1_value
;;;472    /***************负载电流滤波**********************/
;;;473    	Ad7689_Fit_Imon[I_cont++]=var_chV1;
0000dc  f8bd2000          LDRH     r2,[sp,#0]
0000e0  7830              LDRB     r0,[r6,#0]  ; I_cont
0000e2  1c41              ADDS     r1,r0,#1
0000e4  7031              STRB     r1,[r6,#0]
0000e6  0041              LSLS     r1,r0,#1
0000e8  4810              LDR      r0,|L4.300|
0000ea  3010              ADDS     r0,r0,#0x10
0000ec  5242              STRH     r2,[r0,r1]
;;;474    	if(I_cont==30)
0000ee  7831              LDRB     r1,[r6,#0]  ; I_cont
0000f0  291e              CMP      r1,#0x1e
0000f2  d100              BNE      |L4.246|
;;;475    	{
;;;476    		I_cont=0;
0000f4  7035              STRB     r5,[r6,#0]
                  |L4.246|
;;;477    	}
;;;478    //	Bubble_sort( Ad7689_Fit_Imon,20);//排序从大到小
;;;479    	sum1=0;
0000f6  9503              STR      r5,[sp,#0xc]
;;;480    	for(f=0;f<30;f++)
0000f8  9504              STR      r5,[sp,#0x10]
0000fa  e00a              B        |L4.274|
                  |L4.252|
;;;481    	{
;;;482    		sum1 +=Ad7689_Fit_Imon[f];
0000fc  f89d1010          LDRB     r1,[sp,#0x10]
000100  f8301011          LDRH     r1,[r0,r1,LSL #1]
000104  9a03              LDR      r2,[sp,#0xc]
000106  4411              ADD      r1,r1,r2
000108  9103              STR      r1,[sp,#0xc]
00010a  f89d1010          LDRB     r1,[sp,#0x10]         ;480
00010e  1c49              ADDS     r1,r1,#1              ;480
000110  9104              STR      r1,[sp,#0x10]         ;480
                  |L4.274|
000112  f89d1010          LDRB     r1,[sp,#0x10]         ;480
000116  291e              CMP      r1,#0x1e              ;480
000118  d3f0              BCC      |L4.252|
;;;483    	}
;;;484    	Imon1_value=sum1/30;
00011a  9803              LDR      r0,[sp,#0xc]
00011c  211e              MOVS     r1,#0x1e
00011e  fbb0f0f1          UDIV     r0,r0,r1
000122  4907              LDR      r1,|L4.320|
000124  6008              STR      r0,[r1,#0]  ; Imon1_value
;;;485    }
000126  b006              ADD      sp,sp,#0x18
000128  bd70              POP      {r4-r6,pc}
;;;486    
                          ENDP

00012a  0000              DCW      0x0000
                  |L4.300|
                          DCD      ||.bss||
                  |L4.304|
                          DCD      ||.data||
                  |L4.308|
                          DCD      Imon_value
                  |L4.312|
                          DCD      ||.bss||+0x100
                  |L4.316|
                          DCD      Vmon1_value
                  |L4.320|
                          DCD      Imon1_value

                          AREA ||i.AD7689_TransferByte||, CODE, READONLY, ALIGN=2

                  AD7689_TransferByte PROC
;;;404    /************************************************************************/
;;;405    vu16 AD7689_TransferByte(vu16 uiTxData)
000000  b511              PUSH     {r0,r4,lr}
;;;406    {
000002  b081              SUB      sp,sp,#4
;;;407    	vu8 uiRxData;
;;;408    	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
000004  4c0c              LDR      r4,|L5.56|
                  |L5.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L5.6|
;;;409    	SPI_I2S_SendData(SPI2,uiTxData);
000012  f8bd1004          LDRH     r1,[sp,#4]
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_I2S_SendData
                  |L5.28|
;;;410    	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L5.28|
;;;411    	uiRxData = SPI_I2S_ReceiveData(SPI2);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  9000              STR      r0,[sp,#0]
;;;412    	return uiRxData;
000030  f89d0000          LDRB     r0,[sp,#0]
;;;413    }
000034  bd1c              POP      {r2-r4,pc}
;;;414    /************************************************************************/
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40003800

                          AREA ||i.Bubble_sort||, CODE, READONLY, ALIGN=1

                  Bubble_sort PROC
;;;489     */
;;;490    void Bubble_sort(vu16 *D_temp,vu8 num)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;491    {
;;;492    	unsigned int _temp;
;;;493    	unsigned char m,n;
;;;494    	for(m=0;m<num;m++)
000002  2200              MOVS     r2,#0
000004  e017              B        |L6.54|
                  |L6.6|
;;;495    	{
;;;496    		for(n=m;n<num;n++)
000006  4611              MOV      r1,r2
000008  e00f              B        |L6.42|
                  |L6.10|
;;;497    		{
;;;498    			if(D_temp[n]>D_temp[m])//最大的值放在第一位
00000a  f8303011          LDRH     r3,[r0,r1,LSL #1]
00000e  f8304012          LDRH     r4,[r0,r2,LSL #1]
000012  42a3              CMP      r3,r4
000014  d907              BLS      |L6.38|
;;;499    			{
;;;500    				_temp = D_temp[m];
000016  f8303012          LDRH     r3,[r0,r2,LSL #1]
;;;501    				D_temp[m] =D_temp[n];
00001a  f8304011          LDRH     r4,[r0,r1,LSL #1]
00001e  f8204012          STRH     r4,[r0,r2,LSL #1]
;;;502    				D_temp[n]=_temp;		
000022  f8203011          STRH     r3,[r0,r1,LSL #1]
                  |L6.38|
000026  1c49              ADDS     r1,r1,#1              ;496
000028  b2c9              UXTB     r1,r1                 ;496
                  |L6.42|
00002a  f89d3004          LDRB     r3,[sp,#4]            ;496
00002e  4299              CMP      r1,r3                 ;496
000030  d3eb              BCC      |L6.10|
000032  1c52              ADDS     r2,r2,#1              ;494
000034  b2d2              UXTB     r2,r2                 ;494
                  |L6.54|
000036  f89d1004          LDRB     r1,[sp,#4]            ;494
00003a  428a              CMP      r2,r1                 ;494
00003c  d3e3              BCC      |L6.6|
;;;503    			}
;;;504    		}	
;;;505    	}
;;;506    }
00003e  bd1c              POP      {r2-r4,pc}
                          ENDP


                          AREA ||i.SPI_AD7689_Read||, CODE, READONLY, ALIGN=2

                  SPI_AD7689_Read PROC
;;;356    
;;;357    vu16 SPI_AD7689_Read(vu16 AD7689_CFG, vu16 AD7689_INx)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;358    {
000002  b084              SUB      sp,sp,#0x10
;;;359    	vu16 AD7689_Config=0;
000004  2500              MOVS     r5,#0
000006  9503              STR      r5,[sp,#0xc]
;;;360    	vu16 AD7689_Data;
;;;361    	vu8 i;
;;;362    	AD7689_Config = AD7689_CFG<<13|AD7689_INCC<<10|AD7689_INx<<7|AD7689_BW<<6|AD7689_REF<<3|AD7689_SEQ<<1|AD7689_RB;//写入配置参数
000008  f8bd0010          LDRH     r0,[sp,#0x10]
00000c  f8bd1014          LDRH     r1,[sp,#0x14]
000010  0340              LSLS     r0,r0,#13
000012  ea4010c1          ORR      r0,r0,r1,LSL #7
000016  f6414159          MOV      r1,#0x1c59
00001a  4308              ORRS     r0,r0,r1
00001c  9003              STR      r0,[sp,#0xc]
;;;363    	AD7689_Config <<=2;
00001e  f8bd000c          LDRH     r0,[sp,#0xc]
000022  f64f74ff          MOV      r4,#0xffff
000026  ea040080          AND      r0,r4,r0,LSL #2
00002a  9003              STR      r0,[sp,#0xc]
;;;364    	AD7689_CNV_0;
00002c  4e29              LDR      r6,|L7.212|
00002e  2140              MOVS     r1,#0x40
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       GPIO_ResetBits
;;;365    	AD7689_Delay();
000036  f7fffffe          BL       AD7689_Delay
;;;366    	for(i=0;i<16;i++)
00003a  9501              STR      r5,[sp,#4]
00003c  4635              MOV      r5,r6                 ;364
00003e  e032              B        |L7.166|
                  |L7.64|
;;;367    	{
;;;368    		if(AD7689_Config&0x8000)
000040  f8bd000c          LDRH     r0,[sp,#0xc]
000044  0400              LSLS     r0,r0,#16
000046  d504              BPL      |L7.82|
;;;369    		{
;;;370    			GPIO_SetBits(GPIOB,GPIO_Pin_5);//MOSI=1
000048  2120              MOVS     r1,#0x20
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       GPIO_SetBits
000050  e003              B        |L7.90|
                  |L7.82|
;;;371    		}
;;;372    		else
;;;373    		{
;;;374    			GPIO_ResetBits(GPIOB,GPIO_Pin_5);//MOSI=0
000052  2120              MOVS     r1,#0x20
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       GPIO_ResetBits
                  |L7.90|
;;;375    		}
;;;376    		AD7689_Delay();
00005a  f7fffffe          BL       AD7689_Delay
;;;377    		GPIO_ResetBits(GPIOB,GPIO_Pin_3);//SCK=0
00005e  2108              MOVS     r1,#8
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       GPIO_ResetBits
;;;378    		AD7689_Delay();
000066  f7fffffe          BL       AD7689_Delay
;;;379    		AD7689_Config <<= 1;
00006a  f8bd100c          LDRH     r1,[sp,#0xc]
00006e  ea040141          AND      r1,r4,r1,LSL #1
000072  9103              STR      r1,[sp,#0xc]
;;;380    		GPIO_SetBits(GPIOB,GPIO_Pin_3);//SCK=1
000074  2108              MOVS     r1,#8
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       GPIO_SetBits
;;;381    		AD7689_Delay();
00007c  f7fffffe          BL       AD7689_Delay
;;;382    		AD7689_Data <<=1;
000080  f8bd1008          LDRH     r1,[sp,#8]
000084  ea040141          AND      r1,r4,r1,LSL #1
000088  9102              STR      r1,[sp,#8]
;;;383    		if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_4))
00008a  2110              MOVS     r1,#0x10
00008c  4628              MOV      r0,r5
00008e  f7fffffe          BL       GPIO_ReadInputDataBit
000092  b120              CBZ      r0,|L7.158|
;;;384    		{
;;;385    			AD7689_Data |=1;
000094  f8bd0008          LDRH     r0,[sp,#8]
000098  f0400001          ORR      r0,r0,#1
00009c  9002              STR      r0,[sp,#8]
                  |L7.158|
00009e  f89d0004          LDRB     r0,[sp,#4]            ;366
0000a2  1c40              ADDS     r0,r0,#1              ;366
0000a4  9001              STR      r0,[sp,#4]            ;366
                  |L7.166|
0000a6  f89d0004          LDRB     r0,[sp,#4]            ;366
0000aa  2810              CMP      r0,#0x10              ;366
0000ac  d3c8              BCC      |L7.64|
;;;386    		}
;;;387    	}
;;;388    	AD7689_Delay(); 
0000ae  f7fffffe          BL       AD7689_Delay
;;;389    	GPIO_ResetBits(GPIOB,GPIO_Pin_3);//SCK=0
0000b2  2108              MOVS     r1,#8
0000b4  4628              MOV      r0,r5
0000b6  f7fffffe          BL       GPIO_ResetBits
;;;390    	AD7689_Delay(); 
0000ba  f7fffffe          BL       AD7689_Delay
;;;391    	AD7689_CNV_1;
0000be  2140              MOVS     r1,#0x40
0000c0  4628              MOV      r0,r5
0000c2  f7fffffe          BL       GPIO_SetBits
;;;392    	AD7689_Delay(); 
0000c6  f7fffffe          BL       AD7689_Delay
;;;393    	return AD7689_Data;
0000ca  f8bd0008          LDRH     r0,[sp,#8]
;;;394    }
0000ce  b006              ADD      sp,sp,#0x18
0000d0  bd70              POP      {r4-r6,pc}
;;;395    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L7.212|
                          DCD      0x40020400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  AD7689_Buffer
                          %        16
                  Ad7689_Fit_Imon
                          %        200
                  Ad7689_Fit_Imon1
                          %        40
                  Ad7689_Fit_Vmon
                          %        80

                          AREA ||.data||, DATA, ALIGN=0

                  I_cont
000000  00                DCB      0x00
                  I1_cont
000001  00                DCB      0x00
                  V_cont
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\AD7689.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_c2a2045a____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_AD7689_c_c2a2045a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_c2a2045a____REVSH|
#line 144
|__asm___8_AD7689_c_c2a2045a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
