; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\ad7689.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\ad7689.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\ad7689.crf ..\drive\AD7689.c]
                          THUMB

                          AREA ||i.AD7689_Delay||, CODE, READONLY, ALIGN=1

                  AD7689_Delay PROC
;;;168    /************************************************************************/
;;;169    void AD7689_Delay(void)
000000  f44f707a          MOV      r0,#0x3e8
;;;170    {
;;;171    	vu16 count ;
;;;172      for(count = 1000; count != 0; count--);
000004  e001              B        |L1.10|
                  |L1.6|
000006  1e40              SUBS     r0,r0,#1
000008  b280              UXTH     r0,r0
                  |L1.10|
00000a  2800              CMP      r0,#0
00000c  d1fb              BNE      |L1.6|
;;;173    }
00000e  4770              BX       lr
;;;174    void AD7689_Delay1(void)
                          ENDP


                          AREA ||i.AD7689_Delay1||, CODE, READONLY, ALIGN=1

                  AD7689_Delay1 PROC
;;;173    }
;;;174    void AD7689_Delay1(void)
000000  f64030b8          MOV      r0,#0xbb8
;;;175    {
;;;176    	vu16 count ;
;;;177      for(count = 3000; count != 0; count--);
000004  e001              B        |L2.10|
                  |L2.6|
000006  1e40              SUBS     r0,r0,#1
000008  b280              UXTH     r0,r0
                  |L2.10|
00000a  2800              CMP      r0,#0
00000c  d1fb              BNE      |L2.6|
;;;178    }
00000e  4770              BX       lr
;;;179    void AD7689_Scan_CH(void)
                          ENDP


                          AREA ||i.AD7689_InitializeSPI2||, CODE, READONLY, ALIGN=2

                  AD7689_InitializeSPI2 PROC
;;;27     void Bubble_sort(vu16 *D_temp,vu8 num);
;;;28     void AD7689_InitializeSPI2(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;29     {
;;;30     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;31       //SPI_InitTypeDef  SPI_InitStructure;
;;;32       /*!< SD_SPI_CS_GPIO, SD_SPI_MOSI_GPIO, SD_SPI_MISO_GPIO, SD_SPI_DETECT_GPIO 
;;;33            and SD_SPI_SCK_GPIO Periph clock enable 
;;;34     	// 	 RCC_AHBPeriphClockCmd(FLASH_CS_PIN_SCK|FLASH_SCK_PIN_SCK|FLASH_MISO_PIN_SCK | FLASH_MOSI_PIN_SCK, ENABLE);
;;;35       !< SD_SPI Periph clock enable */
;;;36     	/*RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
;;;37     	
;;;38     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
;;;39     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;40     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;41     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//inv
;;;42     	GPIO_Init(GPIOA, &GPIO_InitStructure);//
;;;43       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3;//PC2~3复用功能输出	
;;;44       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
;;;45       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
;;;46       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
;;;47       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
;;;48       GPIO_Init(GPIOC, &GPIO_InitStructure);//初始化
;;;49     	
;;;50     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PB10复用功能输出	
;;;51       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
;;;52       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
;;;53       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
;;;54       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
;;;55       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
;;;56     	
;;;57       GPIO_PinAFConfig(GPIOC,GPIO_PinSource2,GPIO_AF_SPI2); //PC2复用为 SPI2
;;;58     	GPIO_PinAFConfig(GPIOC,GPIO_PinSource3,GPIO_AF_SPI2); //PBC3复用为 SPI2
;;;59     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource10,GPIO_AF_SPI2); //PB13复用为 SPI2
;;;60     	AD7689_CNV_1;
;;;61     	AD7689_Delay();
;;;62     	AD7689_CNV_0;
;;;63     	//这里只针对SPI口初始化
;;;64       SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
;;;65     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
;;;66     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;		//设置SPI的数据大小:SPI发送接收16位帧结构
;;;67     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为高电平
;;;68     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
;;;69     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
;;;70     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
;;;71     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
;;;72     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
;;;73     	SPI_Init(SPI2, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
;;;74     	
;;;75     	SPI_Cmd(SPI2, ENABLE);*/ //使能SPI外设*/
;;;76     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
000004  2602              MOVS     r6,#2
000006  f88d6005          STRB     r6,[sp,#5]
;;;77     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
00000a  2401              MOVS     r4,#1
00000c  f88d4004          STRB     r4,[sp,#4]
;;;78     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000010  2500              MOVS     r5,#0
000012  f88d5006          STRB     r5,[sp,#6]
;;;79     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;//inv
000016  2040              MOVS     r0,#0x40
000018  9000              STR      r0,[sp,#0]
;;;80     	GPIO_Init(GPIOB, &GPIO_InitStructure);//
00001a  4f1a              LDR      r7,|L3.132|
00001c  4669              MOV      r1,sp
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       GPIO_Init
;;;81     
;;;82     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
000024  f88d6005          STRB     r6,[sp,#5]
;;;83     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000028  f88d4004          STRB     r4,[sp,#4]
;;;84     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00002c  f88d5006          STRB     r5,[sp,#6]
;;;85     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//sck,
000030  2008              MOVS     r0,#8
000032  9000              STR      r0,[sp,#0]
;;;86     	GPIO_Init(GPIOB, &GPIO_InitStructure);//
000034  4669              MOV      r1,sp
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       GPIO_Init
;;;87     	
;;;88     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00003c  f88d6005          STRB     r6,[sp,#5]
;;;89     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000040  f88d4004          STRB     r4,[sp,#4]
;;;90     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000044  f88d5006          STRB     r5,[sp,#6]
;;;91     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;//MOSI
000048  2020              MOVS     r0,#0x20
00004a  9000              STR      r0,[sp,#0]
;;;92     	GPIO_Init(GPIOB, &GPIO_InitStructure);//
00004c  4669              MOV      r1,sp
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       GPIO_Init
;;;93     	
;;;94     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;;
000054  f88d5004          STRB     r5,[sp,#4]
;;;95     	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;;
000058  f88d4007          STRB     r4,[sp,#7]
;;;96     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;//MISO
00005c  2010              MOVS     r0,#0x10
00005e  9000              STR      r0,[sp,#0]
;;;97     	GPIO_Init(GPIOB, &GPIO_InitStructure);//
000060  4669              MOV      r1,sp
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       GPIO_Init
;;;98     	
;;;99     	AD7689_CNV_1;
000068  2140              MOVS     r1,#0x40
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       GPIO_SetBits
;;;100    	GPIO_SetBits(GPIOB,GPIO_Pin_5);//MOSI=0
000070  2120              MOVS     r1,#0x20
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       GPIO_SetBits
;;;101    	GPIO_SetBits(GPIOB,GPIO_Pin_3);//SCK=0
000078  2108              MOVS     r1,#8
00007a  4638              MOV      r0,r7
00007c  f7fffffe          BL       GPIO_SetBits
;;;102    }
000080  e8bd81fc          POP      {r2-r8,pc}
;;;103    
                          ENDP

                  |L3.132|
                          DCD      0x40020400

                          AREA ||i.AD7689_Scan_CH||, CODE, READONLY, ALIGN=2

                  AD7689_Scan_CH PROC
;;;178    }
;;;179    void AD7689_Scan_CH(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;180    {
;;;181    	static vu8 I_cont,I1_cont,V_cont;
;;;182    	vu8 i,f;
;;;183    	vu32 sum1;
;;;184    	vu16 var_chI,var_chV,var_chV1;
;;;185    	for(i=0;i<8;i++)
000004  2400              MOVS     r4,#0
;;;186    		{
;;;187    			AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
000006  4d38              LDR      r5,|L4.232|
000008  e00c              B        |L4.36|
                  |L4.10|
00000a  4621              MOV      r1,r4
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       SPI_AD7689_Read
000012  f8250014          STRH     r0,[r5,r4,LSL #1]
;;;188    			AD7689_Delay1();
000016  f7fffffe          BL       AD7689_Delay1
;;;189    			var_chI=AD7689_Buffer[3];
00001a  88e8              LDRH     r0,[r5,#6]  ; AD7689_Buffer
;;;190    			var_chV=AD7689_Buffer[2];
00001c  88af              LDRH     r7,[r5,#4]  ; AD7689_Buffer
;;;191    			var_chV1=AD7689_Buffer[4];
00001e  892e              LDRH     r6,[r5,#8]  ; AD7689_Buffer
000020  1c64              ADDS     r4,r4,#1              ;185
000022  b2e4              UXTB     r4,r4                 ;185
                  |L4.36|
000024  2c08              CMP      r4,#8                 ;185
000026  d3f0              BCC      |L4.10|
;;;192    		}
;;;193    	/***************电源电流滤波**********************/
;;;194    	Ad7689_Fit_Imon1[I1_cont++]=var_chI;
000028  4c30              LDR      r4,|L4.236|
00002a  7861              LDRB     r1,[r4,#1]  ; I1_cont
00002c  1c4a              ADDS     r2,r1,#1
00002e  7062              STRB     r2,[r4,#1]
000030  f8df80b4          LDR      r8,|L4.232|
000034  f1080824          ADD      r8,r8,#0x24
000038  f8280011          STRH     r0,[r8,r1,LSL #1]
;;;195    	if(I1_cont==8)
00003c  7860              LDRB     r0,[r4,#1]  ; I1_cont
00003e  2500              MOVS     r5,#0                 ;185
000040  2808              CMP      r0,#8
000042  d100              BNE      |L4.70|
;;;196    	{
;;;197    		I1_cont=0;
000044  7065              STRB     r5,[r4,#1]
                  |L4.70|
;;;198    	}
;;;199    	Bubble_sort( Ad7689_Fit_Imon1,8);//排序从大到小
000046  4828              LDR      r0,|L4.232|
000048  2108              MOVS     r1,#8
00004a  3024              ADDS     r0,r0,#0x24
00004c  f7fffffe          BL       Bubble_sort
;;;200    	sum1=0;
000050  2100              MOVS     r1,#0
;;;201    	for(f=2;f<6;f++)
000052  2002              MOVS     r0,#2
000054  e004              B        |L4.96|
                  |L4.86|
;;;202    	{
;;;203    		sum1 +=Ad7689_Fit_Imon1[f];
000056  f8382010          LDRH     r2,[r8,r0,LSL #1]
00005a  4411              ADD      r1,r1,r2
00005c  1c40              ADDS     r0,r0,#1              ;201
00005e  b2c0              UXTB     r0,r0                 ;201
                  |L4.96|
000060  2806              CMP      r0,#6                 ;201
000062  d3f8              BCC      |L4.86|
;;;204    	}
;;;205    	Imon_value=sum1/4;
000064  0888              LSRS     r0,r1,#2
000066  4922              LDR      r1,|L4.240|
000068  8008              STRH     r0,[r1,#0]
;;;206    	/***************负载电压滤波**********************/
;;;207    	Ad7689_Fit_Vmon[V_cont++]=var_chV;
00006a  78a0              LDRB     r0,[r4,#2]  ; V_cont
00006c  1c41              ADDS     r1,r0,#1
00006e  70a1              STRB     r1,[r4,#2]
000070  f8df8074          LDR      r8,|L4.232|
000074  f1080838          ADD      r8,r8,#0x38
000078  f8287010          STRH     r7,[r8,r0,LSL #1]
;;;208    	if(V_cont==8)
00007c  78a0              LDRB     r0,[r4,#2]  ; V_cont
00007e  2808              CMP      r0,#8
000080  d100              BNE      |L4.132|
;;;209    	{
;;;210    		V_cont=0;
000082  70a5              STRB     r5,[r4,#2]
                  |L4.132|
;;;211    	}
;;;212    	Bubble_sort( Ad7689_Fit_Vmon,8);//排序从大到小
000084  4818              LDR      r0,|L4.232|
000086  2108              MOVS     r1,#8
000088  3038              ADDS     r0,r0,#0x38
00008a  f7fffffe          BL       Bubble_sort
;;;213    	sum1=0;
00008e  2100              MOVS     r1,#0
;;;214    	for(f=2;f<6;f++)
000090  2002              MOVS     r0,#2
000092  e004              B        |L4.158|
                  |L4.148|
;;;215    	{
;;;216    		sum1 +=Ad7689_Fit_Vmon[f];
000094  f8382010          LDRH     r2,[r8,r0,LSL #1]
000098  4411              ADD      r1,r1,r2
00009a  1c40              ADDS     r0,r0,#1              ;214
00009c  b2c0              UXTB     r0,r0                 ;214
                  |L4.158|
00009e  2806              CMP      r0,#6                 ;214
0000a0  d3f8              BCC      |L4.148|
;;;217    	}
;;;218    	Vmon1_value=sum1/4;
0000a2  0888              LSRS     r0,r1,#2
0000a4  4913              LDR      r1,|L4.244|
0000a6  6008              STR      r0,[r1,#0]  ; Vmon1_value
;;;219    /***************负载电流滤波**********************/
;;;220    	Ad7689_Fit_Imon[I_cont++]=var_chV1;
0000a8  7820              LDRB     r0,[r4,#0]  ; I_cont
0000aa  1c41              ADDS     r1,r0,#1
0000ac  7021              STRB     r1,[r4,#0]
0000ae  4f0e              LDR      r7,|L4.232|
0000b0  3710              ADDS     r7,r7,#0x10
0000b2  f8276010          STRH     r6,[r7,r0,LSL #1]
;;;221    	if(I_cont==8)
0000b6  7820              LDRB     r0,[r4,#0]  ; I_cont
0000b8  2808              CMP      r0,#8
0000ba  d100              BNE      |L4.190|
;;;222    	{
;;;223    		I_cont=0;
0000bc  7025              STRB     r5,[r4,#0]
                  |L4.190|
;;;224    	}
;;;225    	Bubble_sort( Ad7689_Fit_Imon,8);//排序从大到小
0000be  480a              LDR      r0,|L4.232|
0000c0  2108              MOVS     r1,#8
0000c2  3010              ADDS     r0,r0,#0x10
0000c4  f7fffffe          BL       Bubble_sort
;;;226    	sum1=0;
0000c8  2100              MOVS     r1,#0
;;;227    	for(f=2;f<6;f++)
0000ca  2002              MOVS     r0,#2
0000cc  e004              B        |L4.216|
                  |L4.206|
;;;228    	{
;;;229    		sum1 +=Ad7689_Fit_Imon[f];
0000ce  f8372010          LDRH     r2,[r7,r0,LSL #1]
0000d2  4411              ADD      r1,r1,r2
0000d4  1c40              ADDS     r0,r0,#1              ;227
0000d6  b2c0              UXTB     r0,r0                 ;227
                  |L4.216|
0000d8  2806              CMP      r0,#6                 ;227
0000da  d3f8              BCC      |L4.206|
;;;230    	}
;;;231    	Imon1_value=sum1/4;
0000dc  0888              LSRS     r0,r1,#2
0000de  4906              LDR      r1,|L4.248|
0000e0  6008              STR      r0,[r1,#0]  ; Imon1_value
;;;232    }
0000e2  e8bd81f0          POP      {r4-r8,pc}
;;;233    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L4.232|
                          DCD      ||.bss||
                  |L4.236|
                          DCD      ||.data||
                  |L4.240|
                          DCD      Imon_value
                  |L4.244|
                          DCD      Vmon1_value
                  |L4.248|
                          DCD      Imon1_value

                          AREA ||i.AD7689_TransferByte||, CODE, READONLY, ALIGN=2

                  AD7689_TransferByte PROC
;;;151    /************************************************************************/
;;;152    vu16 AD7689_TransferByte(vu16 uiTxData)
000000  b570              PUSH     {r4-r6,lr}
;;;153    {
;;;154    	vu8 uiRxData;
;;;155    	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
000002  4d0c              LDR      r5,|L5.52|
000004  4604              MOV      r4,r0                 ;153
                  |L5.6|
000006  2102              MOVS     r1,#2
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L5.6|
;;;156    	SPI_I2S_SendData(SPI2,uiTxData);
000012  4621              MOV      r1,r4
000014  462c              MOV      r4,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_I2S_SendData
                  |L5.28|
;;;157    	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L5.28|
;;;158    	uiRxData = SPI_I2S_ReceiveData(SPI2);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;159    	return uiRxData;
;;;160    }
000030  bd70              POP      {r4-r6,pc}
;;;161    /************************************************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40003800

                          AREA ||i.Bubble_sort||, CODE, READONLY, ALIGN=1

                  Bubble_sort PROC
;;;236     */
;;;237    void Bubble_sort(vu16 *D_temp,vu8 num)
000000  b530              PUSH     {r4,r5,lr}
;;;238    {
;;;239    	unsigned int _temp;
;;;240    	unsigned char m,n;
;;;241    	for(m=0;m<num;m++)
000002  2300              MOVS     r3,#0
000004  e015              B        |L6.50|
                  |L6.6|
;;;242    	{
;;;243    		for(n=m;n<num;n++)
000006  461a              MOV      r2,r3
000008  e00f              B        |L6.42|
                  |L6.10|
;;;244    		{
;;;245    			if(D_temp[n]>D_temp[m])//最大的值放在第一位
00000a  f8304012          LDRH     r4,[r0,r2,LSL #1]
00000e  f8305013          LDRH     r5,[r0,r3,LSL #1]
000012  42ac              CMP      r4,r5
000014  d907              BLS      |L6.38|
;;;246    			{
;;;247    				_temp = D_temp[m];
000016  f830c013          LDRH     r12,[r0,r3,LSL #1]
;;;248    				D_temp[m] =D_temp[n];
00001a  f8304012          LDRH     r4,[r0,r2,LSL #1]
00001e  f8204013          STRH     r4,[r0,r3,LSL #1]
;;;249    				D_temp[n]=_temp;		
000022  f820c012          STRH     r12,[r0,r2,LSL #1]
                  |L6.38|
000026  1c52              ADDS     r2,r2,#1              ;243
000028  b2d2              UXTB     r2,r2                 ;243
                  |L6.42|
00002a  428a              CMP      r2,r1                 ;243
00002c  d3ed              BCC      |L6.10|
00002e  1c5b              ADDS     r3,r3,#1              ;241
000030  b2db              UXTB     r3,r3                 ;241
                  |L6.50|
000032  428b              CMP      r3,r1                 ;241
000034  d3e7              BCC      |L6.6|
;;;250    			}
;;;251    		}	
;;;252    	}
;;;253    }
000036  bd30              POP      {r4,r5,pc}
                          ENDP


                          AREA ||i.SPI_AD7689_Read||, CODE, READONLY, ALIGN=2

                  SPI_AD7689_Read PROC
;;;103    
;;;104    vu16 SPI_AD7689_Read(vu16 AD7689_CFG, vu16 AD7689_INx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;105    {
;;;106    	vu16 AD7689_Config=0;
;;;107    	vu16 AD7689_Data;
;;;108    	vu8 i;
;;;109    	AD7689_Config = AD7689_CFG<<13|AD7689_INCC<<10|AD7689_INx<<7|AD7689_BW<<6|AD7689_REF<<3|AD7689_SEQ<<1|AD7689_RB;//写入配置参数
000004  0340              LSLS     r0,r0,#13
000006  ea4010c1          ORR      r0,r0,r1,LSL #7
00000a  f6414159          MOV      r1,#0x1c59
00000e  4308              ORRS     r0,r0,r1
;;;110    	AD7689_Config <<=2;
000010  0480              LSLS     r0,r0,#18
000012  0c05              LSRS     r5,r0,#16
;;;111    	AD7689_CNV_0;
000014  4f20              LDR      r7,|L7.152|
000016  2140              MOVS     r1,#0x40
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       GPIO_ResetBits
;;;112    	AD7689_Delay();
00001e  f7fffffe          BL       AD7689_Delay
;;;113    	for(i=0;i<16;i++)
000022  2600              MOVS     r6,#0
000024  e025              B        |L7.114|
                  |L7.38|
;;;114    	{
;;;115    		if(AD7689_Config&0x8000)
000026  0428              LSLS     r0,r5,#16
000028  d504              BPL      |L7.52|
;;;116    		{
;;;117    			GPIO_SetBits(GPIOB,GPIO_Pin_5);//MOSI=1
00002a  2120              MOVS     r1,#0x20
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       GPIO_SetBits
000032  e003              B        |L7.60|
                  |L7.52|
;;;118    		}
;;;119    		else
;;;120    		{
;;;121    			GPIO_ResetBits(GPIOB,GPIO_Pin_5);//MOSI=0
000034  2120              MOVS     r1,#0x20
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       GPIO_ResetBits
                  |L7.60|
;;;122    		}
;;;123    		AD7689_Delay();
00003c  f7fffffe          BL       AD7689_Delay
;;;124    		GPIO_ResetBits(GPIOB,GPIO_Pin_3);//SCK=0
000040  2108              MOVS     r1,#8
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       GPIO_ResetBits
;;;125    		AD7689_Delay();
000048  f7fffffe          BL       AD7689_Delay
;;;126    		AD7689_Config <<= 1;
00004c  0468              LSLS     r0,r5,#17
00004e  0c05              LSRS     r5,r0,#16
;;;127    		GPIO_SetBits(GPIOB,GPIO_Pin_3);//SCK=1
000050  2108              MOVS     r1,#8
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       GPIO_SetBits
;;;128    		AD7689_Delay();
000058  f7fffffe          BL       AD7689_Delay
;;;129    		AD7689_Data <<=1;
00005c  0460              LSLS     r0,r4,#17
00005e  0c04              LSRS     r4,r0,#16
;;;130    		if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_4))
000060  2110              MOVS     r1,#0x10
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       GPIO_ReadInputDataBit
000068  b108              CBZ      r0,|L7.110|
;;;131    		{
;;;132    			AD7689_Data |=1;
00006a  f0440401          ORR      r4,r4,#1
                  |L7.110|
00006e  1c76              ADDS     r6,r6,#1              ;113
000070  b2f6              UXTB     r6,r6                 ;113
                  |L7.114|
000072  2e10              CMP      r6,#0x10              ;113
000074  d3d7              BCC      |L7.38|
;;;133    		}
;;;134    	}
;;;135    	AD7689_Delay(); 
000076  f7fffffe          BL       AD7689_Delay
;;;136    	GPIO_ResetBits(GPIOB,GPIO_Pin_3);//SCK=0
00007a  2108              MOVS     r1,#8
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       GPIO_ResetBits
;;;137    	AD7689_Delay(); 
000082  f7fffffe          BL       AD7689_Delay
;;;138    	AD7689_CNV_1;
000086  2140              MOVS     r1,#0x40
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       GPIO_SetBits
;;;139    	AD7689_Delay(); 
00008e  f7fffffe          BL       AD7689_Delay
;;;140    	return AD7689_Data;
000092  4620              MOV      r0,r4
;;;141    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;142    
                          ENDP

                  |L7.152|
                          DCD      0x40020400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  AD7689_Buffer
                          %        16
                  Ad7689_Fit_Imon
                          %        20
                  Ad7689_Fit_Imon1
                          %        20
                  Ad7689_Fit_Vmon
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  I_cont
000000  00                DCB      0x00
                  I1_cont
000001  00                DCB      0x00
                  V_cont
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\AD7689.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_AD7689_c_c2a2045a____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_AD7689_c_c2a2045a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_AD7689_c_c2a2045a____REVSH|
#line 128
|__asm___8_AD7689_c_c2a2045a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
